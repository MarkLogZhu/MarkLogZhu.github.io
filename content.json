[{"title":"3.JavaScript语法","date":"2017-09-07T12:49:00.000Z","path":"2017/09/07/JavaEE学习/3.JavaScript/3.JavaScript语法/","text":"JaScript 的语法借鉴了很多编译型语言的语法，如 Java (谁叫博主就只会JAVA呢，其他的也不好列举出来)。所以熟悉 Java 的人对于 JavaScript 语法应该是游刃有余的，但是 JavaScript 比 Java 更显宽松，有些地方还是需要注意两者的区别。 字符集JavaScript 采用 Unicode 字符集编写，有关字符集的区别的问题，小伙伴们可以自己 百度下，这里就不详细介绍了。 区分大小写JavaScript 跟 Java 一样是区分大小写，因为他跟 HTML 联系紧密，会给人造成一种不区分大小写的错觉。因此这里要强调下，JavaScript 区分大小写，并且 HTML 中的标签跟属性，在 JavaScript 中必须是小写的，例如 onclick 属性可以在 HTML 中写成 onClick，但在 JavaScript 代码中，必须使用小写的 onclick。 基础语法1. 语句用 JavaScript 编写的脚本，跟其他语言编写出来的脚本是一样的，都由一系列指令组成，这些指令就叫做语句。 JavaScript 语句不像 Java 一样严格，必须以“;”号结尾。但是为了阅读习惯，同时也是一种好的编程习惯，强烈要求必须在语句末尾加上“ ; ”号。 2.注释不是所有的 JavaScript 代码都需要 JavaScript 解释器去解释并执行。有时一些代码，你不想让程序执行的话，就可以使用//（单行注释）或者 /**/（多行注释）来注释掉。例如： 123456789&lt;script type=\"text/javascript\"&gt; function main()&#123; // console.log(\"这是单行注释，你是无法看到的\"); console.log(\"Hello,JavaScript!\"); /** * console.log(\"这是多行注释，你也是无法看到的\"); ** / &#125;&lt;/script&gt; 3.常量与变量 在日常生活中，有些东西是固定不变的,有些东西则会发生变化。例如，人的生日是不会变化的，而人的年龄是会随着时间变化而变化，人们将那些会发生变化的东西成为变量 以上关于变量定义的说明来自于《JavaScript DOM 编程艺术》，从上面我们也可以看出，一般来说，固定不动的数据我们称为 常量 ，而可以改变的数据我们称为 变量。 把值存入常量或变量的操作就叫做 赋值。例如：1234// 将18赋值给age age = 18;// 弹出对话框，显示age的值 alert(age); 了解 Java 语法的人，应该知道在 Java 中必须先声明变量类型再赋值，但是 JavaScript 可以不事先声明就直接赋值。但是提前申明是一种良好的编程习惯，而且也可以区分是全局变量，还是局部变量。 1234// 声明变量 age，并且将18赋值给agevar age = 18;// 弹出对话框，显示age的值alert(age); 12345678var age = 200; // 全局变量test();console.log(age); // 猜猜是200还是18function test()&#123; var age = 18; // 局部变量&#125; 4.基础数据类型在 Java 语言中，声明变量的同时必须同时声明变量的数据类型，这种做法叫做 类型声明。而这种需要同时声明变量的数据类型的语言叫做强类型语言，而 JavaScript 是一种弱类型语言，这意味着可以在任何时候修改数据的类型。例如： 12var age =18;age=\"18\"; 在 Java 中这是非法的，但是 JavaScript 中并没有任何问题， JavaScript 并不在意变量 age 是一个数字还是字符串。 12var age = \"18\"; // Stringvar age Undefined 类型Undefined 类型只有1个值，即 undefined。使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined，直接使用未声明的变量会产生错误。对未声明或已声明但未初始化的变量执行 typeof 运算符会返回 &quot;undefined&quot; 值，例如：(typeof 运算符会在下面讲到) 1234567var message; // 这个变量声明之后默认取得了 undefined 值// var age // 这个变量并没有声明console.log(message); // \"undefined\"console.log(age); // 产生错误console.log(typeof message); // \"undefined\"console.log(typeof age); // \"undefined\" Null 类型Null 类型也只有1个值，即 null。它用来表示值的空缺。你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。在下列场景中应当使用 null。 用来初始化一个变量，这个变量可能赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，作用参数传入。 当函数的返回值期望是对象时，作用返回值传出。 在下列场景中不应当使用 null。 不要使用 null 来检测是否传入了某个参数。 不要使用 null 来检测一个未初始化的变量。 字符串字符串由零个或多个字符组成，字符包括（但不限于）字母、数字、标点符号和空格。字符串必须包在引号里，单引号或双引号都可以。 12var weather = '晴天';var weather = \"晴天\"; 你可以随意选择引号，但是最好根据字符串所包含的字符来选择。比如，字符串里有单引号，就应该选择双引号来包含。反之，就应该选择单引号。12var weather = '今天是个\"晴天\"';var weather = \"今天是个'晴天'\"; 当然也可以跟 Java 类似，选择转义符 \\ 来转义。12var weather = '今天是个\\'晴天\"\\'';var weather = \"今天是个\\\"晴天\\\"\"; 数值JavaScript 支持正负浮点数跟整型 1234var age = 1;var age = -1;var age = 100.1;var age = -100.1; 布尔型布尔类型（boolean）的值有两种,true和false.在非此即彼的场景下，往往使用布尔类型会更简单。 5.数组字符串、数值跟布尔型，只能用来表示一个值，如果需要存储一组值，数组(array) 就要粉墨登场了。 数组是指用一个变量表示一个值的集合,集合中的每个值都是这个数组的一个元素. 在 JavaScript 中用关键字 Array 来声明数组。 123var teams = Array();var teams = Array(4);var teams = &#123;\"足球队\",\"篮球队\",\"排球队\",\"网球队\"&#125;; 数组赋值方式： 123var teams = Array();teams[0] = \"足球队\";teams[0] = \"篮球队\"; 在 Java 语言中数组里面的元素必须是同一类型的，但是在 JavaScript 中就没有这样的限制，数组内的元素可以是不同类型的，设置可以是一个对象或者数组。 12var teams1 = &#123;\"足球队\",10, false&#125;;var teams2 = &#123;\"篮球队\",teams1&#125;; 6.对象与数组类似，对象也是使用一个名字表示一组值。对象的每个值都是它的属性，例如1234var student = Object;student.name=\"张三\";student.age = 18;student.hobby = &#123;\"篮球\"，“跑步”，“编程”&#125;; 创建对象有一种更简洁的语法：1var student = &#123;\"name\":\"张三\",\"age\":18,\"hobby\":\"&#123;'篮球'，'跑步'，'编程'&#125;\"&#125;; 操作算术操作符加 (+)、减(-)、乘(*)、除(/) 就是算术操作符。 条件语句IF 语句在做判断的时候就用到了 IF 语句，它的语法如下： 12345if(条件)&#123; alert(\"满足条件时执行\")；&#125;else&#123; alert(\"不满足条件时执行\");&#125; 条件的结果永远是布尔型，这意味着你可以根据设置的条件实现不同的操作。 毕竟操作符 : 大于操作符 &lt; ：小于操作符 = : 大于等于操作符 &lt;= : 大于等于操作符 == : 等于操作符 != : 不等于操作符 === : 全等于操作符，不仅比较值，还要比较是否为同一类型 !== : 全不等于操作符，不仅比较值，还要比较是否为同一类型 逻辑操作符 &amp;&amp; ：逻辑与 ，两个条件同时等于true，它的值才是true || ：逻辑或 ，有一个条件同时等于true，它的值就是true ! : 逻辑非，取相反值，如果条件值为true，它的值就是false typeof 运算符鉴于 JavaScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型，typeof 就是负责提供这方面信息的运算符。对一个值使用 typeof 运算符可能返回下列某个字符串： &quot;undefined&quot;，如果这个值未声明或已声明但未初始化。 &quot;boolean&quot;，如果这个值是布尔值。 &quot;string&quot;，如果这个值是字符串。 &quot;number&quot;，如果这个值是数值。 &quot;object&quot;，如果这个值是对象或 null。 &quot;function&quot;，如果这个值是函数。 下面是几个使用 typeof 运算符的例子： 1234var message = \"some string\";console.log(typeof message); // \"string\"console.log(typeof(message)); // \"string\"console.log(typeof 95); // \"number\" 从以上例子可以看出，typeof 运算符既可以对变量使用，又可以对字面量使用。由于 typeof 是一个运算符而不是函数，因此例子中的圆括号尽管可以使用，但并不提倡。 typeof null 结果是 &quot;object&quot; 是历史遗留 Bug，在 ECMAScript 6 中，曾经有提案为历史平反, 将 typeof null 的值纠正为 &quot;null&quot;，但最后该提案被拒。理由是历史遗留代码太多，不如继续将错就错。 从技术角度讲，函数在 JavaScript 中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 typeof 运算符来区分函数和其他对象是有必要的。 循环语句要想完成重复性的操作，必然要使用到循环语句了。循环语句有如下三种： while 循环 do…while 循环 for 循环 while 循环while 循环 与 IF语法很相似：123while(条件)&#123; alert(\"满足条件显示的值\");&#125; do…while 循环像 while 循环是必须满足条件才会执行，有一种需求是不管满不满足条件都要执行一次，这种场景下，do…while 循环就派上用场了，它的语法如下：123do&#123; alert(\"不管条件成立与否，都至少执行一次\");&#125; while(条件); for 循环与 while 循环和 do…while 循环 不知道执行次数的情况不同，for 循环需要明确知道循环的次数，它的语法如下： 123for(var i=0;i&lt;循环次数;i++)&#123; alert(\"满足条件显示的值\");&#125; 函数如果需要多次使用同一段代码的话，可以把它们封装成一个函数。函数(function)就是一组允许在你的代码里随时调用的语句，每个函数实际上就是一个短小的脚本。作为良好的编程习惯，应该先定义好函数再调用它。 123function show(showText)&#123; alert(showText);&#125; 如上面示例，我们把传给函数的值叫做参数。 对象在上面我们简单的介绍了对象的声明，在这里我们在详细来了解下对象。 对象是自包含的数据集合，包含在对象里的数据可以通过两种形式来访问– 属性和方法。 属性是隶属于某个特定对象的变量 方法是只有某个特定对象的才能调用的函数 对象就是由一些属性和方法组合在一起的而构成的一个数据实体。在 JavaScript 中，属性和方法都是通过点来访问的，例如：12Object.name;Object.showName(); 内建对象JavaScript 提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象。数组对象就是一种内建对象。 2.宿主对象除了内建对象外，还可以在 JavaScript 脚本中使用一些已经预先定义好的对象，这些对象不是由 JavaScript 本身产生的，而是由它的运行环境产生的，如浏览器。宿主对象包括Form、Image、Element等，我们可以通过这些对象获得关于表单、图片和其他元素的信息。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://marklogzhu.github.io/tags/JavaScript/"},{"name":"前端基础","slug":"前端基础","permalink":"https://marklogzhu.github.io/tags/前端基础/"}]},{"title":"JavaScript纲要","date":"2017-09-07T02:57:00.000Z","path":"2017/09/07/JavaEE学习/3.JavaScript/1.JavaSscript纲要/","text":"什么是 JavaScript首先我们来看下百度百科对于 JavaScript 的定义: JavaScript 是一种 直译式 脚本语言，是一种 动态的、弱类型、基于原型的语言，内置支持类型。它的解释器被称为 JavaScript 引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在 HTML（标准通用标记语言下的一个应用）网页上使用，用来给 HTML 网页增加动态功能。 从上面这段话我们就可以知道 JavaScript 的作用是描述网页行为，与描述网页内容的 HTML和描述网页样式的 CSS 并称为前端三剑客。 JavaScript 由下列3个不同的部分组成： 核心（ECMAScript），由 ECMA-262 定义，提供核心语言功能。 文档对象模型（DOM），提供访问和操作网页内容的方法和接口。 浏览器对象模型（BOM），提供与浏览器交互的方法和接口。","tags":[{"name":"前端","slug":"前端","permalink":"https://marklogzhu.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://marklogzhu.github.io/tags/JavaScript/"}]},{"title":"2.JavaScript使用方式","date":"2017-09-07T02:57:00.000Z","path":"2017/09/07/JavaEE学习/3.JavaScript/2.JavaScript使用方式/","text":"在 HTML 中以元素 &lt;script&gt;来嵌入 JavaScript 代码，当浏览器加载 HTML 文件时会从上至下依次执行 JavaScript 代码。 &lt;script&gt; 有如下两种使用方式 直接在 HTML 页面中嵌入 写在外部 .JS 文件中，然后在 HTML 中引入 1.直接在 HTML 页面中嵌入使用 &lt;script&gt; 元素嵌入 JavaScript 代码时，只需为 &lt;script&gt; 指定 type 属性。然后，像下面这样把 JavaScript 代码直接放在元素内部即可： 12345&lt;script type=\"text/javascript\"&gt; function main()&#123; console.log(\"Hello,JavaScript!\"); &#125;&lt;/script&gt; 注：在 HTML5 规范中，&lt;script&gt; 的 type 属性默认是 &quot;text/javascript&quot;，所以可以省略；但是在 HTML 4.01 和 XHTML 1.0 规范中，type 属性是必须的。 2.引用外部 .JS 文件1&lt;script type=\"text/javascript\" src=\"HelloJavaScript.js\"&gt;&lt;/script&gt; 如上所示，引用外部 .JS 文件需要用到 src 属性。除了引用本地 .JS 文件外，也可以引用网络 .JS 文件。例如： 1&lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt; 当使用了 src 属性后，不应该在 &lt;script&gt; 和 &lt;/script&gt; 元素之间再包含额外的 JavaScript 代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。 123&lt;script type=\"text/javascript\" src=\"HelloJavaScript.js\"&gt; console.log(\"Hello,JavaScript!\"); //永不执行&lt;/script&gt; 3.两种方式比较相比较直接在HTML 中侵入 JavaScript 代码，引用外部文件的方式更值得推荐。 JavaScript 存放位置一般来说，所有的 元素都应该放在页面的 &lt;head&gt; 元素中，例如： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ...... &lt;script type=\"text/javascript\" src=\"HelloJavaScript.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 这里放内容 --&gt;&lt;/body&gt;&lt;/html&gt; 可是这种做法意味着必须等到全部 JavaScript 代码都被下载、解析和执行完成之后，才能开始呈现页面的内容（浏览器在遇到 &lt;body&gt; 元素时才开始呈现内容）。对于那些需要加载很多 JavaScript 代码的页面来说，会导致页面出现明显的延迟（浏览器窗口一片空白）。为了避免这个问题，最好的做法是把 &lt;script&gt; 元素放到 HTML 文档的最后面，&lt;/body&gt; 元素之前，例如： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; ......&lt;/head&gt;&lt;body&gt; &lt;!-- 这里放内容 --&gt; &lt;script type=\"text/javascript\" src=\"HelloJavaScript.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 存放的位置，根据使用场景可以自己选择。","tags":[{"name":"前端","slug":"前端","permalink":"https://marklogzhu.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://marklogzhu.github.io/tags/JavaScript/"}]},{"title":"CSS小结","date":"2017-09-02T09:03:00.000Z","path":"2017/09/02/JavaEE学习/2.CSS/CSS小结/","text":"HTML+CSS基础课程汇总知识，地址为：http://www.imooc.com/learn/9 一、CSS 概念描述1.1 什么是 CSSCSS 全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 1.2 CSS样式的优势使用CSS样式的一个好处是通过定义某个样式，可以让不同网页位置的文字有着统一的字体、字号或者颜色等。 1.3 CSS 语法css 样式由选择符和声明组成，而声明又由属性和值组成，如下所示： 123p&#123; font-size:12px &#125; p 是选择器，font-size 是属性，12px 就是属性值 选择符：又称选择器，指明网页中要应用样式规则的元素，如上面的例子是将网页中所有的段（p）的文字将变成蓝色，而其他的元素不会受到影响。 声明：在英文大括号“｛｝”中的的就是声明，属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔，如下所示：1234p&#123; font-size:12px; color:red;&#125; 1.4 CSS 注释代码在 CSS 中注释用 /*注释语句*/ 来表明 二、CSS 代码存放位置CSS有以下三种形式： 1.内联式 2.嵌入式 3.外部式 2.1 内联式内联式 css 样式表就是把 css 代码直接写在现有的 HTML 标签中，如下面代码：1&lt;p style=\"color:red\"&gt;这里文字是红色。&lt;/p&gt; 并且 css 样式代码要写在 style=””双引号中，如果有多条 css 样式代码设置可以写在一起，中间用分号隔开。1&lt;p style=\"color:red;font-size:12px\"&gt;这里文字是红色。&lt;/p&gt; 2.2 嵌入式嵌入式css样式，就是可以把css样式代码写在标签之间。如下面代码：12345&lt;style type=\"text/css\"&gt;span&#123; color:red;&#125;&lt;/style&gt; 嵌入式css样式必须写在 &lt;style&gt;&lt;/style&gt; 之间，并且一般情况下嵌入式css样式写在 &lt;head&gt;&lt;/head&gt; 之间。 2.3 外部式外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以“.css”为扩展名，在 &lt;head&gt; 内（不是在 &lt;style&gt; 标签内）使用 &lt;link&gt; 标签将css样式文件链接到HTML文件内，如下面代码：1&lt;link href=\"base.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; 注意： 1、css样式文件名称以有意义的英文字母命名，如 main.css。 2、rel=”stylesheet” type=”text/css” 是固定写法不可修改。 3、&lt;link&gt; 标签位置一般写在 &lt;head&gt; 标签之内。 2.4 三种方法的优先级 根据就近原则（离被设置元素越近优先级别越高）来说，应该是 内联式 &gt; 嵌入式 &gt; 外部式 三、CSS 选择器3.1 什么是选择器每一条css样式声明（定义）由两部分组成，形式如下：123选择器&#123; 样式;&#125; “选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素。 3.2 标签选择器标签选择器其实就是html代码中的标签。如 &lt;html&gt;、&lt;body&gt;、&lt;h1&gt;、&lt;p&gt;、&lt;img&gt;。 3.3 类选择器语法： 12345.类选器名称&#123;css样式代码;&#125;注意1、以英文圆点开头2、其中类选器名称可以任意起名（但不要起中文噢） 3.4 id 选择器在很多方面，ID选择器都类似于类选择符，但也有一些重要的区别： 为标签设置id=”ID名称”，而不是class=”类名称”。 ID选择符的前面是井号（#）号，而不是英文圆点（.）。 3.5 类和ID选择器的区别相同点：可以应用于任何元素不同点： 1、ID选择器只能在文档中使用一次。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。2、可以使用类选择器词列表方法为一个元素同时设置多个样式。我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（不能使用 ID 词列表）。 3.6 子选择器还有一个比较有用的选择器子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素。如：1.food&gt;li&#123;border:1px solid red;&#125; 这行代码会使class名为food下的子元素 li 加入红色实线边框。 3.7 包含(后代)选择器包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。如：1.first span&#123;color:red;&#125; 这行代码会使字体颜色变为红色。 请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。后代选择器通过空格来进行选择，而子选择器是通过“&gt;”进行选择。 总结：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。 3.8 通用选择器通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色： 1* &#123;color:red;&#125; 3.9 伪类选择符更有趣的是伪类选择符，为什么叫做伪类选择符，它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：1a:hover&#123;color:red;&#125; 上面一行代码就是为 a 标签鼠标滑过的状态设置字体颜色变红。这样就会使a标签的文字加入鼠标滑过字体颜色变为红色特效。 关于伪选择符：12关于伪类选择符，到目前为止，可以兼容所有浏鉴器的“伪类选择符”就是 a 标签上使用 :hover 了（其实伪类选择符还有很多，尤其是 css3 中，但是因为不能兼容所有浏览器，这里只是讲了这一种最常用的）。其实 :hover 可以放在任意的标签上，比如说 p:hover，但是它们的兼容性也是很不好的，所以现在比较常用的还是 a:hover 的组合。 3.10 分组选择符当你想为 html 中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码为 h1、span标签同时设置字体颜色为红色： 1h1,span&#123;color:red;&#125; 它相当于下面两行代码：12h1&#123;color:red;&#125;span&#123;color:red;&#125; 四、CSS 的继承、层叠和特殊性4.1 继承CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。比如下面代码：如某种颜色应用于p标签，这个颜色设置不仅应用p标签，还应用于p标签中的所有子元素文本，这里子元素为span标签。 123p&#123;color:red;&#125;&lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 执行上面的代码发现p中的文本与span中的文本都设置为了红色。但注意有一些css样式是不具有继承性的。如border:1px solid red;123p&#123;border:1px solid red;&#125;&lt;p&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 在上面例子中它代码的作用只是给p标签设置了边框为1像素、红色、实心边框线，而对于子元素span是没用起到作用的。 4.2 特殊性有的时候我们为同一个元素设置了不同的CSS样式代码，那么元素会启用哪一个CSS样式呢?我们来看一下面的代码：123p&#123;color:red;&#125;.first&#123;color:green;&#125;&lt;p class=\"first\"&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; p和.first都匹配到了p这个标签上，那么会显示哪种颜色呢？green是正确的颜色，那么为什么呢？是因为浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。 下面是权值的规则： 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。例如下面的代码：12345p&#123;color:red;&#125; /*权值为1*/p span&#123;color:green;&#125; /*权值为1+1=2*/.warning&#123;color:white;&#125; /*权值为10*/p span.warning&#123;color:purple;&#125; /*权值为1+1+10=12*/#footer .note p&#123;color:yellow;&#125; /*权值为100+10+1=111*/ 注意：还有一个权值比较特殊–继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 4.3 层叠我们来思考一个问题：如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？ 层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用。 如下面代码:123p&#123;color:red;&#125;p&#123;color:green;&#125;&lt;p class=\"first\"&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 最后 p 中的文本会设置为green，这个层叠很好理解，理解为后面的样式会覆盖前面的样式。 所以前面的css样式优先级就不难理解了：内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 4.4 重要性我们在做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，怎么办？这时候我们可以使用!important来解决。 如下代码：123p&#123;color:red!important;&#125;p&#123;color:green;&#125;&lt;p class=\"first\"&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 这时 p 段落中的文本会显示的red红色。 注意：!important要写在分号的前面 这里注意当网页制作者不设置css样式时，浏览器会按照自己的一套样式来显示网页。并且用户也可以在浏览器中设置自己习惯的样式，比如有的用户习惯把字号设置为大一些，使其查看网页的文本更加清楚。这时注意样式优先级为：浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。 五、CSS 格式化排版5.1 文字排版–字体我们可以使用css样式为网页中的文字设置字体、字号、颜色等样式属性。下面我们来看一个例子，下面代码实现：为网页中的文字设置字体为宋体。1body&#123;font-family:\"宋体\";&#125; 这里注意不要设置不常用的字体，因为如果用户本地电脑上如果没有安装你设置的字体，就会显示浏览器默认的字体。（因为用户是否可以看到你设置的字体样式取决于用户本地电脑上是否安装你设置的字体。）现在一般网页喜欢设置“微软雅黑”，因为这种字体即美观又可以在客户端安全的显示出来（用户本地一般都是默认安装的）。如下代码：1body&#123;font-family:\"Microsoft Yahei\";&#125; 或1body&#123;font-family:\"微软雅黑\";&#125; 注意：第一种方法比第二种方法兼容性更好一些。 5.2 文字排版–字号、颜色可以使用下面代码设置网页中文字的字号为12像素，并把字体颜色设置为#666(灰色)：123body&#123; font-size:12px;color:#666&#125; 5.3 文字排版–粗体我们还可以使用css样式来改变文字的样式：粗体、斜体、下划线、删除线，可以使用下面代码实现设置文字以粗体样式显示出来。1body&#123;font-weight:bold;&#125; 在这里也可以看到，如果想为文字设置粗体是有单独的css样式来实现的，再不用为了实现粗体样式而使用h1-h6或strong标签了。 5.4 文字排版–斜体以下代码可以实现文字以斜体样式在浏览器中显示：123p a&#123;font-style:italic;&#125;&lt;p&gt;三年级时，我还是一个&lt;a&gt;胆小如鼠&lt;/a&gt;的小女孩。&lt;/p&gt; 5.5 文字排版–下划线有些情况下想为文字设置为下划线样式，这样可以在视觉上强调文字，可以使用下面代码来实现：123p a&#123;text-decoration:underline;&#125;&lt;p&gt;三年级时，我还是一个&lt;a&gt;胆小如鼠&lt;/a&gt;的小女孩。&lt;/p&gt; 5.6 文字排版–删除线如果想在网页上设置删除线怎么办，这种场景中电商网站上常会见到 1body&#123;text-decoration:line-through;&#125; 5.7 段落排版–缩进中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现： 1p&#123;text-indent:2em;&#125; 注意：2em的意思就是文字的2倍大小 5.8 段落排版–行间距（行高）我们来学习一下另一个在段落排版中起重要作用的行间距（行高）属性（line-height），如下代码实现设置段落行间距为1.5倍。 1p&#123;line-height:1.5em;&#125; 5.9 段落排版–中文字间距、字母间距中文字间隔、字母间隔设置： 如果想在网页排版中设置文字间隔或者字母间隔就可以使用 letter-spacing 来实现，如下面代码：123456h1&#123; letter-spacing:50px;&#125;......&lt;h1&gt;了不起的盖茨比&lt;/h1&gt;注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。 单词间距设置： 如果我想设置英文单词之间的间距呢？可以使用 word-spacing 来实现。如下代码：12345h1&#123; word-spacing:50px;&#125;...&lt;h1&gt;welcome to imooc!&lt;/h1&gt; 5.10 段落排版–对齐想为块状元素中的文本、图片设置居中样式吗？可以使用text-align样式代码。如下代码可实现文本居中显示1234h1&#123; text-align:center;&#125;&lt;h1&gt;了不起的盖茨比&lt;/h1&gt; 同样可以设置居左：1234h1&#123; text-align:left;&#125;&lt;h1&gt;了不起的盖茨比&lt;/h1&gt; 还可以设置居右：1234h1&#123; text-align:right;&#125;&lt;h1&gt;了不起的盖茨比&lt;/h1&gt; 六、 CSS 盒模型6.1 元素分类在讲解CSS布局之前，我们需要提前知道一些知识，在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。 常用的块状元素有：1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 常用的内联元素有：1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 常用的内联块状元素有：1&lt;img&gt;、&lt;input&gt; 6.2 元素分类–块级元素什么是块级元素？在html中 &lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt; 就是块级元素。设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。1a&#123;display:block;&#125; 块级元素特点： 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行）2、元素的高度、宽度、行高以及顶和底边距都可设置。3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 6.3 元素分类–内联元素在html中， &lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和 &lt;em&gt; 就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码display:inline将元素设置为内联元素。如下代码就是将块状元素div转换为内联元素，从而使 div 元素具有内联元素特点。12345 div&#123; display:inline; &#125;......&lt;div&gt;我要变成内联元素&lt;/div&gt; 内联元素特点： 1、和其他元素都在一行上；2、元素的高度、宽度及顶部和底部边距不可设置；3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 6.4 元素分类–内联块状元素内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码display:inline-block就是将元素设置为内联块状元素。(css2.1新增)， &lt;img&gt;、&lt;input&gt; 标签就是这种内联块状标签。 inline-block 元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。 6.5 盒模型–边框盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。 如下面代码为 div 来设置边框粗细为 2px、样式为实心的、颜色为红色的边框：123div&#123; border:2px solid red;&#125; 上面是 border 代码的缩写形式，可以分开写：12345div&#123; border-width:2px; border-style:solid; border-color:red;&#125; 注意： 1、border-style（边框样式）常见样式有： * dashed（虚线） * dotted（点线） * solid（实线） 2、border-color（边框颜色）中的颜色可设置为十六进制颜色，如:1border-color:#888;//前面的井号不要忘掉。 3、border-width（边框宽度）中的宽度也可以设置为： * thin * medium * thick（但不是很常用） * 最常还是用象素（px） 现在有一个问题，如果有想为 p 标签单独设置下边框，而其它三边都不设置边框样式怎么办呢？css 样式中允许只为一个方向的边框设置样式：1div&#123;border-bottom:1px solid red;&#125; 同样可以使用下面代码实现其它三边(上、右、左)边框的设置：123border-top:1px solid red;border-right:1px solid red;border-left:1px solid red; 6.6 盒模型–宽度和高度盒模型宽度和高度和我们平常所说的物体的宽度和高度理解是不一样的，css内定义的宽（width）和高（height），指的是填充以里的内容范围。因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。元素的高度也是同理。css代码：123456div&#123; width:200px; padding:20px; border:1px solid red; margin:10px; &#125; html代码：123&lt;body&gt; &lt;div&gt;文本内容&lt;/div&gt;&lt;/body&gt; 元素的实际长度为：10px+1px+20px+200px+20px+1px+10px=262px。 6.7 盒模型–填充元素内容与边框之间是可以设置距离的，称之为“填充”。填充也可分为上、右、下、左(顺时针)。如下代码：1div&#123;padding:20px 10px 15px 30px;&#125; 顺序一定不要搞混。可以分开写上面代码：123456div&#123; padding-top:20px; padding-right:10px; padding-bottom:15px; padding-left:30px;&#125; 如果上、右、下、左的填充都为10px;可以这么写1div&#123;padding:10px;&#125; 如果上下填充一样为10px，左右一样为20px，可以这么写：1div&#123;padding:10px 20px;&#125; 6.8 盒模型–边界元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。如下代码：1div&#123;margin:20px 10px 15px 30px;&#125; 也可以分开写：123456div&#123; margin-top:20px; margin-right:10px; margin-bottom:15px; margin-left:30px;&#125; 如果上右下左的边界都为10px;可以这么写：1div&#123; margin:10px;&#125; 如果上下边界一样为10px，左右一样为20px，可以这么写：1div&#123; margin:10px 20px;&#125; 总结一下：padding和margin的区别，padding在边框里，margin在边框外。 七、CSS布局模型7.1 css布局模型清楚了CSS 盒模型的基本概念、 盒模型类型， 我们就可以深入探讨网页布局的基本模型了。布局模型与盒模型一样都是 CSS 最基本、 最核心的概念。 但布局模型是建立在盒模型基础之上，又不同于我们常说的 CSS 布局样式或 CSS 布局模板。如果说布局模型是本，那么 CSS 布局模板就是末了，是外在的表现形式。 CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。 在网页中，元素有三种布局模型：1231、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer） 7.2 流动模型先来说一说流动模型，流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。 流动布局模型具有2个比较典型的特征： 第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 7.3 浮动模型块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示，怎么办呢？不要着急，设置元素浮动就可以实现这一愿望。 任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动，如 div、p、table、img 等元素都可以被定义为浮动。如下代码可以实现两个 div 元素一行显示。12345678div&#123; width:200px; height:200px; border:2px red solid; float:left;&#125;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;div id=\"div2\"&gt;&lt;/div&gt; 效果图 当然你也可以同时设置两个元素右浮动也可以实现一行显示。123456div&#123; width:200px; height:200px; border:2px red solid; float:right;&#125; 效果图 又有小伙伴问了，设置两个元素一左一右可以实现一行显示吗？当然可以：1234567div&#123; width:200px; height:200px; border:2px red solid;&#125;#div1&#123;float:left;&#125;#div2&#123;float:right;&#125; 效果图 7.4 什么是层模型？什么是层布局模型？层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧。但是在网页上局部使用层布局还是有其方便之处的。下面我们来学习一下html中的层布局。 如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作。CSS定义了一组定位（positioning）属性来支持层布局模型。 层模型有三种形式：1231、绝对定位(position: absolute)2、相对定位(position: relative)3、固定定位(position: fixed) 7.5 层模型–绝对定位如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 如下面代码可以实现div元素相对于浏览器窗口向右移动100px，向下移动50px。 div{ width:200px; height:200px; border:2px red solid; position:absolute; left:100px; top:50px;} 效果如下： 7.6 层模型–相对定位如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 如下代码实现相对于以前位置向下移动50px，向右移动100px;12345678910#div1&#123; width:200px; height:200px; border:2px red solid; position:relative; left:100px; top:50px;&#125;&lt;div id=\"div1\"&gt;&lt;/div&gt; 效果图： 什么叫做“偏移前的位置保留不动”呢？ 大家可以做一个实验，如下代码：123&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;span&gt;偏移前的位置还保留不动，覆盖不了前面的div没有偏移前的位置&lt;/span&gt;&lt;/body&gt; 效果图： 从效果图中可以明显的看出，虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。 7.7 层模型–固定定位fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。以下代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。12345678910#div1&#123; width:200px; height:200px; border:2px red solid; position:fixed; left:100px; top:50px;&#125;&lt;p&gt;文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本。&lt;/p&gt;.... 7.8 Relative与Absolute组合使用小伙伴们学习了绝对定位的方法：使用position:absolute可以实现被设置元素相对于浏览器（body）设置定位以后，大家有没有想过可不可以相对于其它元素进行定位呢？答案是肯定的，当然可以。使用position:relative来帮忙，但是必须遵守下面规范： 1、参照定位的元素必须是相对定位元素的前辈元素：123&lt;div id=\"box1\"&gt;&lt;!--参照定位的元素--&gt; &lt;div id=\"box2\"&gt;相对参照元素进行定位&lt;/div&gt;&lt;!--相对定位元素--&gt;&lt;/div&gt; 从上面代码可以看出box1是box2的父元素（父元素当然也是前辈元素了）。 2、参照定位的元素必须加入position:relative;12345#box1&#123; width:200px; height:200px; position:relative; &#125; 3、定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了。12345#box2&#123; position:absolute; top:20px; left:30px; &#125; 这样box2就可以相对于父元素box1定位了（这里注意参照物就可以不是浏览器了，而可以自由设置了）。 八、 CSS 代码缩写，占用更少的带宽8.1 盒模型代码简写还记得在讲盒模型时外边距(margin)、内边距(padding)和边框(border)设置上下左右四个方向的边距是按照顺时针方向设置的：上右下左。具体应用在margin和padding的例子如下：1margin:10px 15px 12px 14px;/*上设置为10px、右设置为15px、下设置为12px、左设置为14px*/ 通常有下面三种缩写方法: 1、如果top、right、bottom、left的值相同，如下面代码：1margin:10px 10px 10px 10px; 可缩写为：1margin:10px; 2、如果top和bottom值相同、left和 right的值相同，如下面代码：1margin:10px 20px 10px 20px; 可缩写为：1margin:10px 20px; 3、如果left和right的值相同，如下面代码：1margin:10px 20px 30px 20px; 可缩写为：1margin:10px 20px 30px; 注意：padding、border的缩写方法和margin是一致的。 8.2 颜色值缩写关于颜色的css样式也是可以缩写的，当你设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。 例子1：1p&#123;color:#000000;&#125; 可以缩写为：1p&#123;color: #000;&#125; 例子2：1p&#123;color: #336699;&#125; 可以缩写为：1p&#123;color: #369;&#125; 8.3 字体缩写网页中的字体css样式代码也有他自己的缩写方式，下面是给网页设置字体的代码：12345678body&#123; font-style:italic; font-variant:small-caps; font-weight:bold; font-size:12px; line-height:1.5em; font-family:\"宋体\",sans-serif;&#125; 这么多行的代码其实可以缩写为一句：123body&#123; font:italic small-caps bold 12px/1.5em \"宋体\",sans-serif;&#125; 注意： 1、使用这一简写方式你至少要指定 font-size 和 font-family 属性，其他的属性(如 font-weight、font-style、font-variant、line-height)如未指定将自动使用默认值。 2、在缩写时 font-size 与 line-height 中间要加入“/”斜扛。 一般情况下因为对于中文网站，英文还是比较少的，所以下面缩写代码比较常用：123body&#123; font:12px/1.5em \"宋体\",sans-serif;&#125; 只是有字号、行间距、中文字体、英文字体设置。 九、单位和值9.1 颜色值在网页中的颜色设置是非常重要，有字体颜色（color）、背景颜色（background-color）、边框颜色（border）等，设置颜色的方法也有很多种： 1、英文命令颜色 前面几个小节中经常用到的就是这种设置方法：1p&#123;color:red;&#125; 2、RGB颜色 这个与 photoshop 中的 RGB 颜色是一致的，由 R(red)、G(green)、B(blue) 三种颜色的比例来配色。1p&#123;color:rgb(133,45,200);&#125; 每一项的值可以是 0~255 之间的整数，也可以是 0%~100% 的百分数。如：1p&#123;color:rgb(20%,33%,25%);&#125; 3、十六进制颜色 这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。1p&#123;color:#00ffff;&#125; 配色表： 9.2 长度值长度单位总结一下，目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。 1、像素 像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设“90像素=1英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。 2、em 就是本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码：1p&#123;font-size:12px;text-indent:2em;&#125; 上面代码就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。 下面注意一个特殊情况： 但当给 font-size 设置单位为 em 时，此时计算的标准以 p 的父元素的 font-size 为基础。如下代码： html:1&lt;p&gt;以这个&lt;span&gt;例子&lt;/span&gt;为例。&lt;/p&gt; css:12p&#123;font-size:14px&#125;span&#123;font-size:0.8em;&#125; 结果 span 中的字体“例子”字体大小就为 11.2px（14 * 0.8 = 11.2px）。 3、百分比1p&#123;font-size:12px;line-height:130%&#125; 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。 十、css样式设置小技巧10.1 水平居中设置-行内元素我们在实际工作中常会遇到需要设置水平居中的场景，比如为了美观，文章的标题一般都是水平居中显示的。 这里我们又得分两种情况：行内元素 还是 块状元素 ，块状元素里面又分为定宽块状元素，以及不定宽块状元素。今天我们先来了解一下行内元素怎么进行水平居中？ 如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。(父元素和子元素：如下面的html代码中，div是“我想要在父容器中水平居中显示”这个文本的父元素。反之这个文本是div的子元素 )如下代码： html代码：123&lt;body&gt; &lt;div class=\"txtCenter\"&gt;我想要在父容器中水平居中显示。&lt;/div&gt;&lt;/body&gt; css代码：12345&lt;style&gt; .txtCenter&#123; text-align:center; &#125;&lt;/style&gt; 10.2 水平居中设置-定宽块状元素当被设置元素为 块状元素 时用 text-align：center 就不起作用了，这时也分两种情况：定宽块状元素和不定宽块状元素。 这一小节我们先来讲一讲定宽块状元素。(定宽块状元素：块状元素的宽度width为固定值。) 满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。我们来看个例子就是设置 div 这个块状元素水平居中： html代码：123&lt;body&gt; &lt;div&gt;我是定宽块状元素，哈哈，我要水平居中显示。&lt;/div&gt;&lt;/body&gt; css代码：123456789&lt;style&gt;div&#123; border:1px solid red;/*为了显示居中效果明显为 div 设置了边框*/ width:200px;/*定宽*/ margin:20px auto;/* margin-left 与 margin-right 设置为 auto */&#125;&lt;/style&gt; 也可以写成：12margin-left:auto;margin-right:auto; 注意：元素的“上下 margin” 是可以随意设置的。 10.3 水平居中总结-不定宽块状元素方法在实际工作中我们会遇到需要为“不定宽度的块状元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。(不定宽块状元素：块状元素的宽度width不固定。) 不定宽度的块状元素有三种方法居中（这三种方法目前使用的都很多）： 1.加入 table 标签 2.设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，进行不定宽元素的属性设置 3.设置 position:relative 和 left:50%：利用 相对定位 的方式，将元素向左偏移 50% ，即达到居中的目的 加入 table 标签为什么选择方法一加入table标签? 是利用table标签的长度自适应性—即不定义其长度也不默认父元素body的长度（table其长度根据其内文本长度决定），因此可以看做一个定宽度块元素，然后再利用定宽度块状居中的margin的方法，使其水平居中。 第一步：为需要设置的居中的元素外面加入一个 table 标签 ( 包括 、、 )。 第二步：为这个 table 设置“左右 margin 居中”（这个和定宽块状元素的方法一样）。 举例如下： html代码：12345678910111213&lt;div&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;ul&gt; &lt;li&gt;我是第一行文本&lt;/li&gt; &lt;li&gt;我是第二行文本&lt;/li&gt; &lt;li&gt;我是第三行文本&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; css代码：123456&lt;style&gt;table&#123; border:1px solid; margin:0 auto;&#125;&lt;/style&gt; 设置 display: inline 方法改变块级元素的 display 为 inline 类型（设置为 行内元素 显示），然后使用 text-align:center 来实现居中效果。如下例子： html代码：123456789&lt;body&gt;&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码：1234567891011121314151617&lt;style&gt;.container&#123; text-align:center;&#125;/* margin:0;padding:0（消除文本与div边框之间的间隙）*/.container ul&#123; list-style:none; margin:0; padding:0; display:inline;&#125;/* margin-right:8px（设置li文本之间的间隔）*/.container li&#123; margin-right:8px; display:inline;&#125;&lt;/style&gt; 这种方法相比第一种方法的优势是不用增加无语义标签，但也存在着一些问题：它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值。 设置浮动和相对定位来实现方法三：通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 我们可以这样理解：假想ul层的父层（即下面例子中的div层）中间有条平分线将ul层的父层（div层）平均分为两份，ul层的css代码是将ul层的最左端与ul层的父层（div层）的平分线对齐；而li层的css代码则是将li层的平分线与ul层的最左端（也是div层的平分线）对齐，从而实现li层的居中。 代码如下：123456789&lt;body&gt;&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt; css代码：1234567891011121314151617&lt;style&gt;.container&#123; float:left; position:relative; left:50%&#125;.container ul&#123; list-style:none; margin:0; padding:0; position:relative; left:-50%;&#125;.container li&#123;float:left;display:inline;margin-right:8px;&#125;&lt;/style&gt; 这三种方法使用得都非常广泛，各有优缺点，具体选用哪种方法，可以视具体情况而定。 10.4 垂直居中-父元素高度确定的单行文本我们在实际工作中也会遇到需要设置垂直居中的场景，比如好多报纸的文章标题在左右一侧时，常常会设置为垂直居中，为了用户体验性好。 这里我们又得分两种情况：父元素高度确定的单行文本，以及父元素高度确定的多行文本。 本节我们先来看第一种父元素高度确定的单行文本, 怎么设置它为垂直居中呢？ 父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度，line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。 line-height 与 font-size 的计算值之差，在 CSS 中成为“行间距”。分为两半，分别加到一个文本行内容的顶部和底部。 这种文字行高与块高一致带来了一个弊端：当文字内容的长度大于块的宽时，就有内容脱离了块。 如下代码：123&lt;div class=\"container\"&gt; hi,imooc!&lt;/div&gt; css代码：1234567&lt;style&gt;.container&#123; height:100px; line-height:100px; background:#999;&#125;&lt;/style&gt; 10.5 垂直居中-父元素高度确定的多行文本父元素高度确定的多行文本、图片等的竖直居中的方法有两种： 方法一：使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。css 中有一个用于竖直居中的属性 vertical-align，在父元素设置此样式时，会对inline-block类型的子元素都有用。下面看一下例子： html代码：1234567&lt;body&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=\"wrap\"&gt;&lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; css代码：1table td&#123;height:500px;background:#ccc&#125; 因为 td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置了。 方法二这种方法兼容性比较差，只是提供大家学习参考。 在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell（设置为表格单元显示），激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式, 兼容性比较差。 html代码：1234567&lt;div class=\"container\"&gt; &lt;div&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;p&gt;看我是否可以居中。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; css代码：12345678&lt;style&gt;.container&#123; height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/&#125;&lt;/style&gt; 这种方法的好处是不用添加多余的无意义的标签，但缺点也很明显，它的兼容性不是很好，不兼容 IE6、7而且这样修改display的block变成了table-cell，破坏了原有的块状元素的性质。 10.6 隐性改变display类型有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 2 个句之一：121. position : absolute2. float : left 或 float:right 简单来说，只要html代码中出现以上两句之一，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。 如下面的代码，小伙伴们都知道 a 标签是 行内元素 ，所以设置它的 width 是 没有效果的，但是设置为 position:absolute 以后，就可以了。 123&lt;div class=\"container\"&gt; &lt;a href=\"#\" title=\"\"&gt;进入课程请单击这里&lt;/a&gt;&lt;/div&gt; css代码 1234567&lt;style&gt;.container a&#123; position:absolute; width:200px; background:#ccc;&#125;&lt;/style&gt;","tags":[{"name":"前端基础","slug":"前端基础","permalink":"https://marklogzhu.github.io/tags/前端基础/"},{"name":"CSS","slug":"CSS","permalink":"https://marklogzhu.github.io/tags/CSS/"}]},{"title":"HTML小结","date":"2017-08-29T09:03:00.000Z","path":"2017/08/29/JavaEE学习/1.HTML/HTML小结/","text":"一、HTML概念描述1.什么是 HTMLHTML 是英文 Hyper Text Mark-up Language( 超文本标记语言 )的缩写，它规定了自己的语法规则，用来表示比“文本”更丰富的意义，比如图片，表格，链接等。 简单来说 HTML 就是给文本加上各种表明文本含义的标签，让人和程序对文本有更直观的认识。 2.什么是 HTML 标签* HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 * HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt; * HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt; * 标签对中的第一个标签是开始标签，第二个标签是结束标签 * 开始和结束标签也被称为开放标签和闭合标签 * 所有的标签都必须关闭，以及，大部分的内容都在标签之间，他们的格式是这样的：起始标签 - 内容 - 闭合标签 3.HTML 属性* HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息 * 属性总是以名称/值对的形式出现，比如：name=&quot;value&quot; * 属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。 * 在某些个别的情况下，比如属性值本身就含有双引号，那么就必须使用单引号 * 属性总是在 HTML 元素的开始标签中规定 二、HTML 结构&lt;html&gt; &lt;head&gt; &lt;title&gt;第一个Html文档&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 这是一个最基本的 HTML文件 &lt;/body&gt; &lt;/html&gt; 如上面所看到的，一个 HTML 文件中有一个根标签 html，里面包含了 head 头部标签跟 body 主体标签。其中 head 标签用来描述页面信息，如页面标题、编码格式等，body 标签内的内容就是实际被用户看到的信息 常用 head 标签结构标签 标签 描述 html 表示一个HTML 页面 head 头部信息，含有页面信息属性 body 主页信息，含页面显示内容 div 块容器 head 常用标签 标签 描述 title 定义了页面标题 style 定义了页面样式文件 meta 定义了页面中的元数据 link 定义了页面与一个外部资源的关系 script 定义了客户端的脚本文件 body 常用标签 标签 描述 img 图片标签 a 超链接 字体标签 标签 描述 strong 加粗 em 斜体 列表标签 标签 描述 ol 有序列表标签 ul 无序列表标签 li 列表内容项 属性顺序HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。 1.class 2.id, name 3.data-* 4.src, for, type, href 5.title, alt 6.aria-*, role","tags":[{"name":"前端基础","slug":"前端基础","permalink":"https://marklogzhu.github.io/tags/前端基础/"},{"name":"HTML","slug":"HTML","permalink":"https://marklogzhu.github.io/tags/HTML/"}]},{"title":"查看 SQL SERVER 版本信息","date":"2017-08-25T02:30:00.000Z","path":"2017/08/25/SQL/查看SQL SERVER 版本信息/","text":"sql 版本信息SELECT SERVERPROPERTY(&apos;Edition&apos;) AS Edition, CASE SERVERPROPERTY(&apos;EditionID&apos;) WHEN 1804890536 THEN &apos;Enterprise Edittion: CAL Lincenseing&apos; WHEN 1872460670 THEN &apos; Enterprise Edition: Core-based Licensing&apos; WHEN 610778273 THEN &apos;Enterprise Evaluation&apos; WHEN 284895786 THEN &apos; Business Intelligence&apos; WHEN -2117995310 THEN &apos;Developer&apos; WHEN -1592396055 THEN &apos;Express&apos; WHEN -133711905 THEN &apos;Express with Advanced Services&apos; WHEN -1534726760 THEN &apos;Standard&apos; WHEN 1293598313 THEN &apos;Web&apos; ELSE &apos;&apos; END AS [Licensing Model] SELECT SERVERPROPERTY(&apos;servername&apos;) AS 实例名, SERVERPROPERTY(&apos;ProductVersion&apos;) AS 实例版本, SERVERPROPERTY(&apos;Edition&apos;) AS 产品版本, SERVERPROPERTY(&apos;ProductLevel&apos;) AS 版本级别, @@VERSION AS 版本信息 查看CPU数和user scheduler数目SELECT cpu_count,scheduler_count FROM sys.dm_os_sys_info 查看最大工作线程数SELECT max_workers_count FROM sys.dm_os_sys_info","tags":[{"name":"SQL","slug":"SQL","permalink":"https://marklogzhu.github.io/tags/SQL/"},{"name":"SQL SERVER","slug":"SQL-SERVER","permalink":"https://marklogzhu.github.io/tags/SQL-SERVER/"}]},{"title":"form表单用 GET 方法进行 URL 传值时后台无法获取问题","date":"2017-08-07T14:03:00.000Z","path":"2017/08/07/java/form表单用get方法进行url传值时后台无法获取问题/","text":"问题描述&lt;a href=&quot;${pageContext.request.contextPath}/client?method=add&quot;&gt;点我&lt;/a&gt; &lt;form action=&quot;${pageContext.request.contextPath }/client?method=add&quot; method=&quot;get&quot;&gt; &lt;p&gt;First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;/p&gt; &lt;p&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; form 表单使用 GET 方式提交数据，后台打印不出来参数 method 的值，在浏览器地址栏中也不显示值，地址栏显示如下： http://localhost:8888/CRM/client?fname=1&amp;lname=1 使用 POST 方式地址栏就能显示参数 method http://localhost:8888/CRM/client?method=addUser 问题原因表单提交时 GET 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在URL中可以看到。自己添加的参数会被清除掉。如果需要添加参数的话，可以用一个隐藏的字段来添加，如： &lt;input type=&quot;hidden&quot; name=&quot;method&quot; value=&quot;add&quot;&gt;","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"ajax 使用","date":"2017-07-27T12:39:40.000Z","path":"2017/07/27/前端/ajax/","text":"ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 原生 ajax 步骤： 123456789101112131415161718// 1.创建一个核心对象 XMLHttpRequestxmlhttp = null;if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();&#125;else if(window.ActiveXObject)&#123; xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;// 2.编写一个回调函数xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123; //接受服务器回送过来的数据 alert(xmlhttp.responseText); &#125;&#125;// 3.编写请求方式及请求路径xmlhttp.open(\"get\".\"$&#123;pageContext.request.contextPath&#125;/ajax1\")// 4.发送请求xmlhttp.send();","tags":[{"name":"前端","slug":"前端","permalink":"https://marklogzhu.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://marklogzhu.github.io/tags/JavaScript/"},{"name":"jQuest","slug":"jQuest","permalink":"https://marklogzhu.github.io/tags/jQuest/"}]},{"title":"SQLServer 多表筛选数据","date":"2017-07-13T02:22:00.000Z","path":"2017/07/13/SQL/SQLServer多表筛选数据/","text":"概述 在项目中常常出现多表数据对比的需求，今天我们就来完成下这个需求。 需求某小学一年级有 A、B 两个班，实现如下需求1.查出两个班相同名字和年龄的学生2.查出两个班不同名字和年龄的学生 实现首先我们来生成下测试数据。 测试数据1234567891011121314151617-- A 班SELECT '张三' AS name,'18' AS age INTO #TEMP_A UNION ALLSELECT '李四' AS name,'28' AS ageUNION ALLSELECT '王五' AS name,'38' AS ageUNION ALLSELECT '赵六' AS name,'48' AS age -- B 班SELECT '田七' AS name,'18' AS age INTO #TEMP_B UNION ALLSELECT '老刘' AS name,'28' AS ageUNION ALLSELECT '张三' AS name,'18' AS ageUNION ALLSELECT '赵六' AS name,'48' AS age 查出两个班相同名字和年龄的学生123SELECT name,age FROM #TEMP_AINTERSECTSELECT name,age FROM #TEMP_B 查出两个班不同名字和年龄的学生123SELECT name,age FROM #TEMP_AEXCEPT SELECT name,age FROM #TEMP_B 总结以上的示例主要运用了以下两个运算符 INTERSECT：返回由 INTERSECT 运算符左侧和右侧的查询都返回的所有非重复值。 EXCEPT：返回由 EXCEPT 运算符左侧的查询返回、而又不包含在右侧查询所返回的值中的所有非重复值。 注：这两个运算符需要在 SQL SERVER 2005 版本之后（包括 2005 版）才能使用","tags":[{"name":"SQL","slug":"SQL","permalink":"https://marklogzhu.github.io/tags/SQL/"},{"name":"SQLServer","slug":"SQLServer","permalink":"https://marklogzhu.github.io/tags/SQLServer/"}]},{"title":"常用小工具","date":"2017-06-30T06:06:00.000Z","path":"2017/06/30/tool/常用工具/","text":"所谓工欲善其事必先利其器，今天就介绍下笔者日常使用的一些小工具 Markdown 编辑器使用 Markdown 的优点这里就不赘述，不了解的朋友可以看下这里 为什么我们要学习 Markdown 的三个理由 Markdown 语法说明(简体中文版) 也可以先使用在线 Markdown 编辑器体验下 MaHua dillinger 笔者私心里认为还是 CS 版的编辑器书写更流畅，这里也推荐两款客户端 Markdown 编辑器 MarkdownPad2 haroopad 相对于 haroopad 的免费， MarkdownPad2 专业版是收费的，这里也给各位准备了个 MarkdownPad2 的授权密钥 邮箱地址： Soar360@live.com 授权秘钥：1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtL A2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== SpaceSniffer 磁盘清理工具SpaceSniffer 下载地址 不知不觉中硬盘空间就所剩无几了，到底是什么文件占用这么高呢，通过 SpaceSniffer 我们就可以很清晰的知道各个文件的占用率，然后找出罪魁祸首将他斩于马下。 SpaceSniffer 支持选中后直接删除，如果不按住 Shift 键的话最后还得手工清空回收站 SqlServer 数据库备份软件SqlServer 数据库备份软件 下载地址 在信息化时代，最贵的莫过于数据了，所以为了数据的安全，定时备份数据库当然是必不可少的。但是光光只是在本地做数据库备份而不做异地备份的话，还是存在着很大的风险。所以我们既要做到定时备份又要做到异地备份. 虽然 SqlServer 自带的备份计划也能做到，但是想要同时做到异地备份的话还需要额外的脚本操作。通过 SqlServer 数据库备份软件 软件就可以做到本地定时备份的同时也可以向另一台设备上传输刚备份的数据库文件。 市面上同类型数据库异地备份的服务经过询问在三万元一个点，但是使用该软件将省却这一笔费用。","tags":[{"name":"tool","slug":"tool","permalink":"https://marklogzhu.github.io/tags/tool/"}]},{"title":"批量插入数据库记录","date":"2017-06-28T13:45:00.000Z","path":"2017/06/28/net/批量插数据库数据/","text":"一、场景描述在生活中，我们经常看到快递员拿着特制的移动终端，扫描着多个快递面单实现快递单的运输记录。 当没有网络的情况下，移动终端会将数据存储在本地，等有网络的情况下，会将数据统一提交到后台。而这个也就是我们今天要做的将批量数据插入到数据库中去。 二、ScanLog表结构 字段名 字段类型 字段含义 rowId INT 自增主键 barcode NVACHAR(30) 快递单号 jobNumer NVACHAR(20) 操作人员编号 state INT 单据状态 doTime DATATIME 操作时间 doPlace NVACHAR(10) 所在网点编号 Tel NVACHAR(15) 联系电话 三、注意点1.数据不是单条记录，而是批量操作 2.表中可能已存在相同快递单号的记录 3.本次提交数据中可能存在重复记录 4.执行效率，移动终端不可能长时间等待后台的返回，所以要在几秒内就能将响应结果返回至终端去 四、实现逻辑1.先将数据通过for循环拼接插入临时表中去 2.将临时表与ScanLog表连接，将非重复数据插入表中 3.将结果返回给终端 五、实现代码12345678910111213141516171819202122232425#region 添加扫描记录/// &lt;summary&gt;/// 添加扫描记录/// &lt;/summary&gt;/// &lt;param name=\"scanList\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool addRecord(List&lt;ScanRecordModel&gt; scanList) &#123; bool flag = false; StringBuilder strSql = new StringBuilder(); StringBuilder sql = new StringBuilder(); String s = String.Empty; String DoTime = DateTime.Now.ToString(); strSql.Append(\" SELECT * INTO #temp FROM ( \"); foreach (ScanRecordModel scan in scanList) &#123; s = \" SELECT '&#123;0&#125;'as barcode ,'&#123;1&#125;' as jobnumer,'&#123;2&#125;' as doTime,'&#123;3&#125;' as doPlace,'&#123;4&#125;' as Tel UNION ALL \"; strSql.Append(String.Format(s, scan.barcode, scan.user.jobNumber, DoTime, scan.netPoint.rowId,scan.tel)); &#125; sql.Append(StringUtils.removeLastChar(strSql.ToString(), \"UNION ALL\")); sql.Append(\" )a \"); sql.Append(\" INSERT INTO ScanRecord(Barcode,JobNumer,DoTime,DoPlace,tel) \"); sql.Append(\" SELECT DISTINCT * FROM #temp WHERE NOT EXISTS (SELECT 1 FROM ScanRecord where ScanRecord.Barcode=#temp.Barcode) \"); flag = SqlHelper.ExecCmd(sql.ToString()) &gt; 0; return flag;&#125;#endregion","tags":[{"name":"C#，SQL","slug":"C-，SQL","permalink":"https://marklogzhu.github.io/tags/C-，SQL/"}]},{"title":"SQL小技巧之统计SQL执行时间","date":"2017-06-27T13:25:00.000Z","path":"2017/06/27/SQL/SQL小技巧之统计SQL执行时间/","text":"1.计算执行SQL语句所需时间衡量SQL语句写的怎么样，除了性能方面的考虑，SQL的执行时间也常常可以体现。 通过 SQL的内置函数 GETDATE() 就可以很方便的获取SQL执行时间了 例如： 1234DECLARE @runTime DATETIMESET @runTime = GETDATE()SELECT COUNT(*) FROM SysUserSELECT DATEDIFF(MS,@runTime,GETDATE()) as 毫秒 结果： 2.计算执行SQL存储过程所需时间同理,我们也可以统计执行一个存储过程所需时间 1234declare @runTime datetimeset @runTime = GETDATE()EXEC [dbo].[proc_test]SELECT DATEDIFF(MS,@runTime,GETDATE()) as 毫秒 结果：","tags":[{"name":"SQL","slug":"SQL","permalink":"https://marklogzhu.github.io/tags/SQL/"}]},{"title":"hexo","date":"2017-05-24T11:45:00.000Z","path":"2017/05/24/hexo/hexo/","text":"什么是 hexohexo 是博客框架，将支持的类型的文件转换成静态Web页面（html+css+JavaScript）。 常用命令 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate :生成 hexo s == hexo server :启动服务预览 hexo s -p 500 == hexo server :启动服务修改端口为5000预览 hexo d == hexo deploy :部署","tags":[{"name":"hexo","slug":"hexo","permalink":"https://marklogzhu.github.io/tags/hexo/"}]},{"title":"JSP","date":"2017-04-08T08:13:00.000Z","path":"2017/04/08/java/JavaWeb/07.JSP/","text":"一、JSP介绍什么是 JSP？JSP全称是 Java Server Pages，它和 servle 技术一样，都是 SUN 公司定义的一种用于开发动态 web 资源的技术。 JSP 用来干什么？相对于 HTML 只能为用户提供静态数据，Jsp 技术允许在页面中嵌套 java 代码，为用户提供动态数据。实现将内容的生成和信息的展示相分离。 二、JSP 语法在 JSP 中所有 JAVA 语法都可以实现。 &lt;% … %&gt;java代码片段 &lt;%= … %&gt;输出表达式 相当于out.print(); &lt;%! … %&gt;声明成员 &lt;%– 注释内容 –%&gt;JSP 注释 JSP 原理JSP 也是一个 Servlet，当访问 JSP 页面时，服务器会将 JSP 页面转为一个 Servlet。在 Tomcat 服务器的 work\\Catalina\\localhost\\项目名\\org\\apache\\jsp 目录下可以看到转换后的 Servlet 源码。 示例： HelloJsp.jsp12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 声明成员变量 --%&gt; &lt;%!int wage = 2500;%&gt; &lt;%-- 声明成员变量 --%&gt; &lt;% int alimony = 3000; %&gt; &lt;%-- 两者比较 --%&gt; &lt;%=wage &gt; alimony%&gt;&lt;/body&gt;&lt;/html&gt; index_jsp.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;public final class HelloJsp_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent &#123; int wage = 2500; private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory.getDefaultFactory(); private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants; private javax.el.ExpressionFactory _el_expressionfactory; private org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123; return _jspx_dependants; &#125; public void _jspInit() &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); &#125; public void _jspDestroy() &#123; &#125; public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try &#123; response.setContentType(\"text/html; charset=UTF-8\"); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(\"\\r\\n\"); out.write(\"&lt;!DOCTYPE html PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\"&gt;\\r\\n\"); out.write(\"&lt;html&gt;\\r\\n\"); out.write(\"&lt;head&gt;\\r\\n\"); out.write(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;\\r\\n\"); out.write(\"&lt;title&gt;Insert title here&lt;/title&gt;\\r\\n\"); out.write(\"&lt;/head&gt;\\r\\n\"); out.write(\"&lt;body&gt;\\r\\n\"); out.write(\"\\t\"); out.write('\\r'); out.write('\\n'); out.write(' '); out.write('\\r'); out.write('\\n'); out.write(' '); out.write('\\r'); out.write('\\n'); out.write(' '); int alimony = 3000; out.write('\\r'); out.write('\\n'); out.write(' '); out.write('\\r'); out.write('\\n'); out.write(' '); out.print(wage &gt; alimony); out.write(\"\\r\\n\"); out.write(\"&lt;/body&gt;\\r\\n\"); out.write(\"&lt;/html&gt;\"); &#125; catch (java.lang.Throwable t) &#123; if (!(t instanceof javax.servlet.jsp.SkipPageException))&#123; out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125; if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); &#125; &#125; finally &#123; _jspxFactory.releasePageContext(_jspx_page_context); &#125; &#125;&#125; 三、JSP 指令JSP 指令（directive）是为 JSP 引擎而设计的，它们并不直接产生任何可见输出，而只是告诉引擎如何处理 JSP 页面中的其余部分。 #####格式: &lt;%@指令名称 属性=&quot;值&quot; 属性=&quot;值&quot;%&gt; #####jsp指令分类: * page * include * taglib 注意: 一个页面中可以出现多个指令 指令可以放在任意位置,一般都放在 JSP 页面最上面. page 指令page 指令主要声明 JSP 页面的一些属性 常用属性 contentType设置响应流的编码,及通知浏览器用什么编码打开.设置文件的mimetype pageEncoding设置页面的编码 import导入所需要的包 ontentType和pageEncoding若两者都出现的时候,各自使用各自的编码 若只出现一者,两个都使用出现的这个编码 若两者都不出现,使用服务器默认的编码 tomcat7使用的iso-8859-1 language当前jsp页面里面可以嵌套的语言 buffer设置jsp页面的流的缓冲区的大小 autoFlush是否自动刷新 extends声明当前jsp的页面继承于那个类.必须继承的是httpservlet 及其子类 session设置jsp页面是否可以使用session内置对象 isELIgnored是否忽略el表达式 errorPage当前jsp页面出现异常的时候要跳转到的jsp页面 isErrorPage当前jsp页面是否是一个错误页面,若值为true,可以使用jsp页面的一个内置对象 exception include 指令静态包含,就是将其他页面或者servlet的内容包含进来,一起进行编译运行.生成一个java文件.格式: &lt;%@include file=&quot;相对路径或者是内部路径&quot; %&gt; taglib指令导入标签库，格式: &lt;%@taglib prefix=&quot;前缀名&quot; uri=&quot;名称空间&quot; %&gt; 使用格式： &lt;前缀名:标签 .. &gt; 四、JSP 九大内置对象JSP 引擎在调用 JSP 对应的 _jspServlet 时，会传递或创建9个与 web 开发相关的对象供 _jspServlet使用。 NO 内置对象 类型 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable pageContext 对象pageContext 对象是JSP技术中最重要的一个对象，它代表 JSP 页面的运行环境，这个对象不仅封装了对其它 8 大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了 web 开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。 通过 pageContext 获得其他对象 * getException 方法返回 exception 隐式对象 * getPage 方法返回 page 隐式对象 * getRequest 方法返回 request 隐式对象 * getResponse 方法返回 response 隐式对象 * getServletConfig 方法返回 config 隐式对象 * getServletContext 方法返回 application 隐式对象 * getSession 方法返回 session 隐式对象 * getOut 方法返回 out 隐式对象 pageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。常用方法： void setAttribute(java.lang.String name,java.lang.Object value)注册使用页面范围语义指定的名称和值。如果传入的值为 null，则调用此方法与调用 removeAttribute( name, PageContext.PAGE_SCOPE ) 产生的效果相同。 java.lang.Object getAttribute(java.lang.String name)从所有范围中移除与给定名称关联的对象引用。如果没有此类对象，则不执行任何操作。 void removeAttribute(java.lang.String name)从所有范围中移除与给定名称关联的对象引用。如果没有此类对象，则不执行任何操作。 java.lang.Object findAttribute(java.lang.String name)按顺序在页面、请求、会话（如果有效）和应用程序范围中搜索指定属性，并返回关联的值或 null。 out 对象out 对象用于向客户端发送文本数据。out 对象是通过调用 pageContext 对象的 getOut 方法返回的，其作用和用法与 ServletResponse.getWriter 方法返回的 PrintWriter 对象非常相似。 page 对象page对象表示当前一个 JSP 页面，可以理解为一个对象本身，即：把一个 JSP 当作一个对象来看待。page 对象在开发中几乎不用，了解一下即可 示例:123456789101112131415161718&lt;%--设置属性 --%&gt;&lt;% pageContext.setAttribute(\"name\", \"且听风吟\"); request.setAttribute(\"value1\", 1); application.setAttribute(\"value2\", 2); session.setAttribute(\"value3\", 3);%&gt;&lt;%-- 获取属性 --%&gt;name:&lt;%=pageContext.getAttribute(\"name\")%&gt;&lt;br&gt;value1:&lt;%=pageContext.findAttribute(\"value1\")%&gt;&lt;br&gt;value2:&lt;%=pageContext.findAttribute(\"value2\")%&gt;&lt;br&gt;value3:&lt;%=pageContext.findAttribute(\"value3\")%&gt;&lt;br&gt;&lt;%--查找一个没有的属性 --%&gt;value4:&lt;%=pageContext.findAttribute(\"value4\")%&gt; 五、JSP 属性范围所谓的属性范围就是一个属性设置之后，可以经过多少个其他页面后仍然可以访问的保存范围。范围分类： 当前页：一个属性只能在一个页面中取得，跳转到其他页面无法取得 一次服务器请求：一个页面中设置的属性，只要经过了服务器跳转，则跳转之后的页面可以继续取得。 一次会话：一个用户设置的内容，只要是与此用户相关的页面都可以访问（一个会话表示一个人，这个人设置的东西只要这个人不走，就依然有效） 上下文中：在整个服务器上设置的属性，所有人都可以访问 以下四个对象作用域： * application 整个项目 * session 一次会话 * request 一次请求 * pageContext 一个页面 六、JSP 标签JSP 标签也称之为 Jsp Action(JSP动作)元素，它用于在 JSP 页面中提供业务逻辑功能，避免在 JSP 页面中直接编写 JAVA 代码，造成 JSP 页面难以维护。 JSP 的常用标签: * &lt;jsp:include&gt;标签 * &lt;jsp:forward&gt;标签 * &lt;jsp:param&gt;标签 &lt; jsp:include &gt;标签此标签用于把另外一个资源的输出内容插入进当前 JSP 页面的输出内容之中，这种在JSP页面执行时的引入方式称之为动态引入。语法： &lt;jsp:include page=&quot;relativeURL | &lt;%=expression%&gt;&quot; flush=&quot;true|false&quot; /&gt; page 属性用于指定被引入资源的相对路径，它也可以通过执行一个表达式来获得。flush 属性指定在插入其他资源的输出内容时，是否先将当前JSP页面的已输出的内容刷新到客户端。 &lt; jsp:include&gt;标签与include指令的区别 &lt; jsp:include&gt; 标签是动态引入， 标签涉及到的2个JSP页面会被翻译成2个servlet，这2个servlet的内容在执行时进行合并。 而include指令是静态引入，涉及到的2个JSP页面会被翻译成一个servlet，其内容是在源文件级别进行合并。 示例： 1234567891011121314 &lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jsp的jsp:include标签测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--使用jsp:include标签引入其它JSP页面--%&gt; &lt;jsp:include page=\"/head.jsp\"/&gt; &lt;h1&gt;网页主体内容&lt;/h1&gt; &lt;jsp:include page=\"/foot.jsp\"/&gt; &lt;/body&gt;&lt;/html&gt; ###&lt; jsp:forward&gt;标签 &lt; jsp:forward&gt;标签用于把请求转发给另外一个资源。语法： &lt;jsp:forward page=&quot;relativeURL | &lt;%=expression%&gt;&quot; /&gt; page属性用于指定请求转发到的资源的相对路径，它也可以通过执行一个表达式来获得。 示例：123&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;%--使用&lt;jsp:forward&gt;标签跳转到forwarddemo02.jsp--%&gt;&lt;jsp:forward page=\"/forwarddemo02.jsp\"/&gt; &lt; jsp:param&gt;标签当使用&lt; jsp:include&gt; 和 &lt; jsp:forward&gt; 标签引入或将请求转发给其它资源时，可以使用 &lt; jsp:param&gt; 标签向这个资源传递参数。语法1： 123&lt;jsp:include page=\"relativeURL | &lt;%=expression%&gt;\"&gt; &lt;jsp:param name=\"parameterName\" value=\"parameterValue|&lt;%= expression %&gt;\" /&gt;&lt;/jsp:include&gt; 语法2：123&lt;jsp:forward page=\"relativeURL | &lt;%=expression%&gt;\"&gt; &lt;jsp:param name=\"parameterName\" value=\"parameterValue|&lt;%= expression %&gt;\" /&gt;&lt;/jsp:include&gt; &lt; jsp:param&gt;标签的 name 属性用于指定参数名，value 属性用于指定参数值。在&lt; jsp:include&gt;和&lt; jsp:forward&gt;标签中可以使用多个&lt; jsp:param&gt;标签来传递多个参数。","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"会话技术之 Cookie 和 Session","date":"2017-04-07T13:34:00.000Z","path":"2017/04/07/java/JavaWeb/06.会话技术之Cookie和Session/","text":"一、会话会话是什么？会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 会话用来干什么？保存浏览器与服务器通信时产生的数据 有哪些会话技术？ Cookie Cookie 是客户端技术，程序把每个用户的数据以 cookie 的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 Session Session 是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的 session 对象，由于 session 为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的 session 中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的 session 中取出数据为用户服务。 Cookie 与 Session的区别 Cookie 是把数据写给浏览器。 Session 把数据写到每一个浏览器对应的独占 session 中。 Session 对象由服务器创建，开发人员可以调用 request 对象的 getSession 方法得到session对象。 二、常用方法Cookie 常用方法 Cookie(String name, String value)构造带指定名称和值的 cookie,cookie 的名称在创建之后不得更改。 void setComment(String purpose)指定一个 cookie 用途的注释。 String getComment()返回描述此 cookie 用途的注释；如果该 cookie 没有注释，则返回 null。 setDomain(String pattern)指定应在其中显示此 cookie 的域。 String getDomain()返回为此 cookie 设置的域名。 void setMaxAge(int expiry)设置 cookie 的最大生存时间，以秒为单位。0 值会导致删除 cookie。 int getMaxAge()返回以秒为单位指定的 cookie 的最大生存时间，默认情况下，-1 指示该 cookie 将保留到浏览器关闭为止。 setPath(String uri)设置cookie 的路径。 String getPath()返回浏览器将此 cookie 返回到的服务器上的路径。 void setSecure(boolean flag)指示浏览器是否只能使用安全协议（如 HTTPS 或 SSL）发送 cookie。 boolean getSecure()如果浏览器仅通过安全协议发送 cookie，则返回 true；如果浏览器可以使用任何协议发送 cookie，则返回 false。 String getName()返回 cookie 的名称。名称在创建之后不得更改。 void setValue(String newValue)在创建 cookie 之后将新值分配给 cookie String getValue()返回 cookie 的值。 int getVersion()返回此 cookie 遵守的协议版本。 void setVersion(int v)设置此 cookie 遵守的 cookie 协议版本。 clone()重写标准 java.lang.Object.clone 方法以返回此 cookie 的副本。 Session 常用方法 long getCreationTime()返回创建此会话的时间 String getId()返回包含分配给此会话的唯一标识符的字符串 long getLastAccessedTime()返回客户端上一次发送与此会话关联的请求的时间 ServletContext getServletContext()返回此会话所属的 ServletContext void setMaxInactiveInterval(int interval)指定在 servlet 容器使此会话失效之前客户端请求之间的时间间隔，以秒为单位。负数时间指示会话永远不会超时。 int getMaxInactiveInterval()返回 servlet 容器在客户端访问之间将使此会话保持打开状态的最大时间间隔，以秒为单位。 Object getAttribute(String name)返回与此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回 null。 java.util.Enumeration getAttributeNames()返回包含绑定到此会话的所有对象的名称的 String 对象的 Enumeration。 void setAttribute(String name, Object value)使用指定名称将对象绑定到此会话。如果具有同样名称的对象已经绑定到该会话，则替换该对象。 void removeAttribute(String name)从此会话中移除与指定名称绑定在一起的对象。如果会话没有与指定名称绑定在一起的对象，则此方法不执行任何操作。 void invalidate()使此会话无效，然后取消对任何绑定到它的对象的绑定。 boolean isNew()如果客户端还不知道该会话，或者客户端选择不加入该会话，则返回 true。例如，如果服务器仅使用基于 cookie 的会话，而客户端已经禁止了 cookie 的使用，则每个请求上的会话都将是新会话。 三、编码实践 获取上一次访问时间 123456789101112131415161718192021222324252627private static final String LAST_ACCESS_TIME = \"lastAccessTime\";protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置输出字符集 response.setCharacterEncoding(\"utf-8\"); // 获取输出流 PrintWriter writer = response.getWriter(); // 获取Cookie数组 Cookie[] cookies = request.getCookies(); if (cookies == null) &#123; writer.write(\"第一次访问...\"); &#125; else &#123; writer.write(\"上次访问时间为：\"); for (Cookie cookie : cookies) &#123; if (LAST_ACCESS_TIME.equals(cookie.getName())) &#123; Long lastAccessTime = Long.parseLong(cookie.getValue()); Date date = new Date(lastAccessTime); java.text.DateFormat format1 = new java.text.SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); writer.write(format1.format(date)); &#125; &#125; &#125; Cookie cookie = new Cookie(LAST_ACCESS_TIME, \"\" + System.currentTimeMillis()); response.addCookie(cookie);&#125; ####结果： 第一次访问： 第二次访问： cookie中存取中文 12Cookie cookie = new Cookie(\"userName\", URLEncoder.encode(\"且听风吟\", \"UTF-8\"));response.addCookie(cookie); cookie中获取中文 1URLDecoder.decode(cookie.getValue(), \"UTF-8\") session 基本使用 1服务器创建 session 出来后，会把 session 的id号，以 cookie 的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着 session 的 id 号去，服务器发现客户机浏览器带 session id 过来了，就会使用内存中与之对应的 session 为之服务。 12345678910111213141516171819protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置编码格式 response.setCharacterEncoding(\"UTF-8\"); // 获取输出流 PrintWriter writer = response.getWriter(); // 获取Session,若没有则新建 HttpSession session = request.getSession(); // 设置值 session.setAttribute(\"name\", \"且听风吟\"); // 获取SessionId String sessionId = session.getId(); // 判断是否第一次创建Session if (session.isNew()) &#123; writer.print(\"第一次创建Session，id为:\" + sessionId); &#125; else &#123; writer.print(\"已存在Session，id为:\" + sessionId); &#125;&#125; 结果： 四、注意Cookie 在读取Cookie，然后操作时，除了getName(),getValue()外，不要妄图得到其他信息，其他方法不会得到值的 一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。 一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。 浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。 Session session对象的创建时机在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的 session对象的销毁时机session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间.如：1234&lt;!-- 设置Session的有效时间:以分钟为单位--&gt;&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt; 当需要在程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session。123HttpSession session = request.getSession();// 手工调用session.invalidate方法，摧毁sessionsession.invalidate();","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Hibernate 框架","date":"2017-04-07T13:34:00.000Z","path":"2017/04/07/java/Hibernate/01.Hibernate/","text":"一、Hibernate 简介在了解 Hibernate 之前，我们先了解下什么是 ORM 。 1.1 ORM 概述ORM 全称为 Object Relational Mapping，翻译过来就是对象关系映射 * O：面向对象领域的 Object（JavaBean对象） * R：关系数据库领域的 Relational（表的结构） * M：映射 Mapping（XML的配置文件） 1.2 什么是 HibernateHibernate 是一个开放源代码的对象关系映射框架。它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架。 1.3 Hibernate 能干什么 自动生成 SQL 语句并执行 数据持久化 1.4 Hibernate 优点 Hibernate 对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 Hibernate是一个基于 JDBC 的主流持久化框架，是一个优秀的 ORM 实现，它很大程度的简化了 DAO 层编码工作 Hibernate 的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 简单来说，Hibernate 框架就是使我们可以通过操作对象的方式操作数据库。 二、Hibernate 环境搭建1.1 下载 Hibernate 开发包Hibernate开发包 1.2 Hibernate 包结构说明1.2 eclipse 搭建将","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://marklogzhu.github.io/tags/JAVA/"}]},{"title":"Servlet之response","date":"2017-03-31T13:00:00.000Z","path":"2017/03/31/java/JavaWeb/05.Servlet之response/","text":"一、Response简介Response是什么？Request代表着一个 HTTP 响应对象，里面存放着 HTTP 的响应消息 什么时候被创建？当调用 Servlet 的 service() 方法时创建 谁创建？由Servlet容器创建 能干什么向客户端输出数据 Response的层次结构-- javax.servlet.ServletResponse -- javax.servlet.http.HttpServletResponse 二、常用方法 设置响应编码格式 setCharacterEncoding(“UTF-8”) 只能设置输出流中字符的编码格式，优先级最高，可以覆盖其他方法的设置 setContentType(“text/html;charset=UTF-8”) 设置输出流字符的编码格式的同时也可以设置浏览器的解码格式，优先级其次，只能覆盖比他优先级低的方法 setLocale(new java.util.Locale(“zh”,”CN”)) 只能设置输出流中字符的编码格式 ，优先级最低 负责向客户端(浏览器)发送数据的相关方法 ServletOutputStream getOutputStream()返回适用于在响应中编写二进制数据的 ServletOutputStream PrintWriter getWriter()返回可将字符文本发送到客户端的 PrintWriter 对象,默认字符集为 ISO-8859-1 负责向客户端(浏览器)发送响应头的相关方法 void addCookie(Cookie cookie)添加 Cookie 对象，同名的 Cookie 会覆盖 void addDateHeader(String name, long date)以 KEY_VALUE 的形式添加日期响应头 void addHeader(String name, String value)以 KEY_VALUE 的形式添加响应头 负责向客户端(浏览器)发送响应状态码的相关方法 void setStatus(int sc)设置响应状态码 响应状态码的常量 int SC_OK 200:正常响应 int SC_NOT_FOUND 404:用户操作错误 int SC_METHOD_NOT_ALLOWED405:访问的方法不存在 int SC_INTERNAL_SERVER_ERROR500:内部错误 三、编码实践 使用 getWriter() 向页面输出汉字 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(\"utf-8\"); PrintWriter writer = response.getWriter(); writer.print(\"且听风吟,且待琴终。\"); writer.close();&#125; 结果： 使用 getOutputStream() 向页面输出汉字 123456789protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = \"且听风吟,且待琴终。\"; // 通过设置响应头控制浏览器以UTF-8的编码显示数据 response.setHeader(\"content-type\", \"text/html;charset=UTF-8\"); ServletOutputStream out = response.getOutputStream(); out.write(data.getBytes(\"UTF-8\")); out.close();&#125; 结果： ![](http://oajxivjud.bkt.clouddn.com/responseDemo01.png) 文件下载 1234567891011121314151617181920212223protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.获取要下载的文件的绝对路径 String realPath = this.getServletContext().getRealPath(\"/download/中文文件名.TXT\"); // 2.获取要下载的文件名 String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); // 3.设置content-disposition响应头控制浏览器以下载的形式打开文件,注意中文文件名要转码 response.setHeader(\"content-disposition\", \"attachment;filename=\" + URLEncoder.encode(fileName, \"UTF-8\")); // 4.获取要下载的文件输入流 InputStream in = new FileInputStream(realPath); int len = 0; // 5.创建数据缓冲区 byte[] buffer = new byte[1024]; // 6.通过response对象获取OutputStream流 OutputStream out = response.getOutputStream(); // 7.将FileInputStream流写入到buffer缓冲区 while ((len = in.read(buffer)) &gt; 0) &#123; // 8.使用OutputStream将缓冲区的数据输出到客户端浏览器 out.write(buffer, 0, len); &#125; in.close();&#125; 结果： 注：下载文件时避免使用 PrintWriter 流，因为 PrintWriter 流是字符流，只能处理字符数据，会导致数据丢失。而 OutputStream 流是字节流，可以处理任何数据，所以下载文件要使用 OutputStream 流。 生成随机数字验证码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setHeader(&quot;refresh&quot;, &quot;5&quot;);// 设置refresh响应头控制浏览器每隔5秒钟刷新一次 // 1.在内存中创建一张图片 BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB); // 2.得到图片 Graphics2D g = (Graphics2D) image.getGraphics(); g.setColor(Color.WHITE);// 设置图片的背景色 g.fillRect(0, 0, 80, 20);// 填充背景色 // 3.向图片上写数据 g.setColor(Color.BLUE);// 设置图片上字体的颜色 g.setFont(new Font(null, Font.BOLD, 20)); g.drawString(getRandomCode(), 0, 20); // 4.设置响应头控制浏览器浏览器以图片的方式打开 response.setContentType(&quot;image/jpeg&quot;); // 等同于response.setHeader(&quot;Content-Type&quot;,&quot;image/jpeg&quot;); // 5.设置响应头控制浏览器不缓存图片数据 response.setDateHeader(&quot;expries&quot;, -1); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); // 6.将图片写给浏览器 ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream()); } 12345private String getRandomCode() &#123; Random ran = new Random(); String num = (ran.nextInt(8999999) + 1000000) + \"\"; return num;&#125; 结果： ![](http://oajxivjud.bkt.clouddn.com/RandomCode.gif) 设置响应头控制浏览器的行为 设置http响应头控制浏览器禁止缓存当前文档内容 123 response.setDateHeader(\"expries\", -1);response.setHeader(\"Cache-Control\", \"no-cache\");response.setHeader(\"Pragma\", \"no-cache\"); 设置http响应头控制浏览器定时刷新网页(refresh) 12//设置refresh响应头控制浏览器每隔5秒钟刷新一次response.setHeader(\"refresh\", \"5\"); 通过response实现请求重定向 请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。 应用场景：用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程 实现方式：response.sendRedirect(String location)，即调用 response 对象的 sendRedirect 方法实现请求重定向 sendRedirect内部的实现原理：使用 response 设置 302 状态码和设置location响应头实现重定向 1234 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.sendRedirect(\"/day01_Servlet/hello.html\");&#125;","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Servlet之request","date":"2017-03-30T13:00:00.000Z","path":"2017/03/30/java/JavaWeb/04.Servlet之request/","text":"一、Request简介Request是什么？Request代表着一个HTTP请求对象，里面存放着请求参数和属性。 什么时候被创建？当调用 Servlet 的 service() 方法时创建 谁创建？由Servlet容器创建，这个对象自动封装了请求方式及参数等信息 能干什么可以找到请求从哪里发出，请求什么资源，带什么参数，获取Session对象和客户端的Cookie ServletRequest的层次结构-- javax.servlet.ServletRequest -- javax.servlet.http.HttpServletRequest 二、常用方法 void setAttribute(String name,Object o)以 KEY-VLUE 的形式设置属性 Object getAttribute(String name)以 Object 形式返回指定属性的值，如果不存在给定名称的属性，则返回 null。 void removeAttribute(String name)移除指定属性 Enumeration getAttributeNames()返回包含此请求可用属性的名称的 Enumeration。如果该请求没有可用的属性，则此方法返回一个空的 Enumeration void setCharacterEncoding(String env)设置请求正文编码字符集 String getCharacterEncoding()获取请求正文编码字符集 String getContentType()获取返回请求主体的MIME类型 String getParameter(String name)以 String 形式返回请求参数的值，如果该参数不存在，则返回 null String[] getParameterValues(String name)返回包含给定请求参数拥有的所有值的 String 对象数组，如果该参数不存在，则返回 null String getMethod()获取请求的 HTTP 方法的名称，例如GET，POST或PUT String getRequestURI()获取请求URI,获取的是 从项目名到参数之前的内容 StringBuffer getRequestURL()获取请求URL,获取的带协议的完整路径 String getQueryString()get请求的所有参数 String getProtocol()获取协议和版本 String getScheme()获取请求方案名称，如 http、https 或 ftp String getServerName()获取包含服务器名称的 String，如 IP 地址 int getServerPort()获取服务器端口号 String getRemoteAddr()获取客户端IP地址 java.util.Locale getLocale()基于 Accept-Language 头，返回客户端将用来接受内容的首选 Locale boolean isSecure()返回一个 boolean 值，指示此请求是否是使用安全通道（比如 HTTPS）发出的 三、编码实践 属性设置、获取、移除 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String tag = \"name\"; request.setAttribute(tag, \"张三\"); System.out.println(tag + request.getAttribute(tag)); request.removeAttribute(tag); System.out.println(tag + request.getAttribute(tag));&#125; 结果： 12name:张三name:null 字符集的获取与设置 12345protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"正文编码字符集：\" + request.getCharacterEncoding()); request.setCharacterEncoding(\"utf-8\"); System.out.println(\"正文编码字符集：\" + request.getCharacterEncoding());&#125; 结果： 12正文编码字符集：null正文编码字符集：utf-8 获取客户端信息 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"客户端IP地址：\" + request.getRemoteAddr()); System.out.println(\"请求方式：\" + request.getScheme()); System.out.println(\"是否是HTTPS请求：\" + request.isSecure()); System.out.println(\"请求方式：\" + request.getMethod());&#125; 结果： 1234客户端IP地址：0:0:0:0:0:0:0:1请求方式：http是否是HTTPS请求：false请求方式：GET 获取服务端信息 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"服务器端口号：\" + request.getServerPort()); System.out.println(\"服务器名称：\" + request.getServerName()); System.out.println(\"项目名称：\" + request.getContextPath());&#125; 结果： 123服务器端口号：8888服务器名称：localhost项目名称：/day01_Servlet 获取请求消息12345678protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"不带协议路径：\" + request.getRequestURI()); System.out.println(\"带协议路径：\" + request.getRequestURL()); System.out.println(\"请求方式：\" + request.getMethod()); System.out.println(\"get请求的所有参数:\" + request.getQueryString()); System.out.println(\"协议和版本：\" + request.getProtocol());&#125; 结果： 12345不带协议路径：/day01_Servlet/request带协议路径：http://localhost:8888/day01_Servlet/request请求方式：GETget请求的所有参数:null协议和版本：HTTP/1.1","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Servlet之ServletConfig与ServletContext对象","date":"2017-03-19T13:00:00.000Z","path":"2017/03/19/java/JavaWeb/03.Servlet之ServletConfig和ServletContext对象/","text":"在 Servlet之生命周期 中我们除了提到三个生命周期方法之外，还提到了二个方法 getServletConfig()和getServletInfo()，他返回的对象分别是ServletConfig和ServletContext对象，今天就让我们来学习下这两个对象 一、ServletConfig简介官方定义：A servlet configuration object used by a servlet container to pass information to a servlet during initialization.中文翻译：一个servlet的配置对象，用来给servlet容器传递信息到servlet，在Servlet初始化的时候。 简单来说 ServletConfig 就是一个配置对象，通过它可以很方便的获取 web.xml 中配置的信息 二、ServletConfig常用方法* String getInitParameter(java.lang.String name) 作用：返回一个包含指定初始化参数值的字符串，如果参数不存在，则返回null。 * Enumeration&lt;String&gt; getInitParameterNames() 作用： 返回servlet的初始化参数的名称作为String对象的枚举，如果servlet没有初始化参数，则返回空枚举。 * ServletContext getServletContext() 作用：返回对调用者正在执行的ServletContext的引用。 * String getServletName() 作用：获取servlet实例的名称 三、编码实践 1.编写Servlet类 12345678910111213141516171819202122232425262728import java.io.IOException;import java.util.Enumeration;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletConfigDemo extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.getServletConfig() ServletConfig config = this.getServletConfig(); // 2.getServletName() System.out.println(\"ServletName:\" + config.getServletName()); // 3.getInitParameter() System.out.println(\"大写KEY值:\" + config.getInitParameter(\"NAME\")); System.out.println(\"小写KEY值:\" + config.getInitParameter(\"name\")); // 4.getInitParameterNames() Enumeration&lt;String&gt; enumeration = config.getInitParameterNames(); while (enumeration.hasMoreElements()) &#123; String name = enumeration.nextElement(); String value = config.getInitParameter(name); System.out.println(\"name-----------&gt;\" + name); System.out.println(\"value-----------&gt;\" + value); &#125; &#125;&#125; 2.编写web.xml配置 1234567891011121314&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;ServletConfigDemo&lt;/display-name&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mark.day01.ServletConfigDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;markLogZhu&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletConfig&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.运行，查看结果 4.注 例子中 getInitParameter() 方法的 key 参数为大写，而 web.xml 中 key 为小写，可以看到返回的值为null，证明参数区分大小写 四、ServletContext简介在整个web应用中，只有一个ServletContext，WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。当项目被移除的时候或者服务器关闭的时候servletcontext也同时被销毁 五、ServletContext的常用方法 1.获取ServletContext实例 方式一： 1ServletContext servletContext = this.getServletContext(); 方式二： 1ServletContext servletContext = this.getServletConfig().getServletContext(); 2.利用ServletContext实现数据共享 写数据 12ServletContext servletContext = config.getServletContext();servletContext.setAttribute(\"name\", \"markLogZhu\"); 读数据 12ServletContext servletContext = getServletConfig().getServletContext(); System.out.println(\"value:\"+servletContext.getAttribute(\"name\")); 3.获取 web.xml 配置信息(跟 ServletConfig 对象的 getInitParameterNames()方法一样) web.xml配置 1234567891011121314&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;ServletConfigDemo&lt;/display-name&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mark.day01.ServletConfigDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;markLogZhu&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletConfig&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 获取配置信息 12345678ServletContext context = this.getServletContext();Enumeration enumeration = context.getInitParameterNames();while(enumeration.hasMoreElements())&#123; String name = (String) enumeration.nextElement(); String value = (String) context.getInitParameter(name); System.out.println(\"name：\"+name); System.out.println(\"value：\"+value.toString());&#125; 4.Servlet的转发 Servlet类 12345 ServletContext context = this.getServletContext(); //在request设置参数，然后在jsp界面中获取。 req.setAttribute(\"name\", \"value\");RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/index.jsp\");requestDispatcher.forward(req,resp); jsp界面获取数据： 1234&lt;% String value = (String)request.getAttribute(\"name\"); System.out.println(\"value：\"+value);%&gt; 5.读取资源的配置文件 123456789101112ServletContext context = this.getServletContext();InputStream inputStream = context.getResourceAsStream(\"/db.properties\");ByteArrayOutputStream outStream = new ByteArrayOutputStream();byte[] by = new byte[1024];int len = 0;while((len = inputStream.read(by))!= -1)&#123; outStream.write(by, 0, len);&#125;String content = new String(outStream.toByteArray());System.out.println(\"content：\"+content);outStream.close();inputStream.close(); 六、参考：java_web学习第二天(ServletConfig和ServletContext对象的作用和使用)","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Servlet之生命周期","date":"2017-03-19T10:10:00.000Z","path":"2017/03/19/java/JavaWeb/02.Servlet之生命周期/","text":"一、Servlet简介JavaServlet 是用 Java 语言编写的服务端程序。其主要功能是接收和响应客户端的请求。 二、Servlet结构-- Servlet 接口 -- GenericServlet 抽象类 -- HttpServlet 抽象类 -- 自定义业务Servlet 业务类 三、Servlet接口方法=======================生命周期方法开始====================================== * void init(ServletConfig config) 作用：初始化方法 调用者：服务器 调用时机：默认第一次访问的时候或load-on-startup中设置正整数值时(值越大优先级越低) 调用次数：一次 * void service(ServletRequest req, ServletResponse res) 作用：处理业务逻辑方法 调用者：服务器 调用时机：请求来的时候 调用次数：请求来一次调用一次 * void destroy() 作用：初始化方法 调用者：服务器 调用时机：Service被移除或服务器正常关闭时 调用次数：一次 =======================生命周期方法结束====================================== * ServletConfig getServletConfig() 作用：获得任何初始化和启动参数信息 * String getServletInfo() 作用：获取有关其自身的基本信息，比如作者、版本和版权 四、编码实践Servlet生命周期 1.编写类 123456789101112131415161718192021222324252627282930313233import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class LifeServlet implements Servlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println(\"init()调用\"); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(\"service()调用\"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(\"destroy()调用\"); &#125;&#125; 2.配置web.xml文件(若new类为Servlet，IDE默认已配置，可跳过此步) 12345678910&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;LifeServlet&lt;/display-name&gt; &lt;servlet-name&gt;LifeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mark.day01.LifeServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LifeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/life&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.启动Tomcat 4.按步骤操作对照结果 4.1 在浏览器中输入项目地址(http://localhost:8888/day01_Servlet/life) 注1：因笔者电脑中先安装了 IIS，后安装 Tomcat，所以为了解决端口冲突所以将端口设为8888 注2：每个人的项目名称和包名不同，请按自己的实际项目修改web.xml跟浏览器地址 4.2 查看控制器输出 4.3 在浏览器中刷新页面，然后查看控制器输出 可以发现service方法又一次被调用了，而init()方法只在第一次访问时调用 4.4 关闭Tomcat,查看控制器输出 注： 五、总结serlvet是一个单实例多线程对象，默认第一次访问的时候,服务器创建servlet,并调用init实现初始化操作.并调用一次service方法。每当请求来的时候,服务器创建一个线程,调用service方法执行自己的业务逻辑。当serlvet被移除的时候服务器正常关闭的时候,服务器调用servlet的destroy方法实现销毁操作.","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"web.xml","date":"2017-03-19T03:11:00.000Z","path":"2017/03/19/java/JavaWeb/01.web,xml/","text":"一、web.xml简介web.xml是JavaWeb项目的配置文件，主要用来配置欢迎页、servlet、filter等信息，如果你的项目不需要配置这些信息的话，也可以不创建这个文件 二、常用标签 指定欢迎页面 1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index1.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 注：指定两个欢迎页，如果index.jsp不存在就寻找index1.jsp 命名与定制URL(如：Servlet和JSP) 命名 123456&lt;servlet&gt; &lt;!-- Servlet名字，可以随便取，有多个Servlet时不允许重名 --&gt; &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt; &lt;!-- 指定实现这个Servlet的类。完整的包名+类名 --&gt; &lt;servlet-class&gt;net.test.TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt; 定义URL 123456&lt;servlet-mapping&gt; &lt;!--必须和&lt;servlet&gt;里的&lt;servlet-name&gt;内容一样--&gt; &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt; &lt;!-- 指定访问这个Servlet的URL。这里给出的是对于整个Web应用的相对URL路径 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt; /servlet-mapping&gt; 定制初始化参数 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt; &lt;servlet-class&gt;net.test.TestServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 参数名 --&gt; &lt;param-name&gt;E-mail&lt;/param-name&gt; &lt;!-- 参数值 --&gt; &lt;param-value&gt;Tommy@163.com&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;userName&lt;/param-name&gt; &lt;param-value&gt;Tommy&lt;/param-value&gt; &lt;/init-param&gt;&lt; /servlet&gt; 在Servlet类中取值：getServletConfig().getInitParameter(&quot;E-mail&quot;) 指定错误处理页面 12345&lt;!-- 错误码 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error404.jsp&lt;/location&gt;&lt;/error-page&gt; 12345&lt;!-- 异常类型 --&gt;&lt;error-page&gt; &lt;exception-type&gt;Java.lang.Exception&lt;exception-type&gt; &lt;location&gt;/exception.jsp&lt;location&gt;&lt;/error-page&gt; 过滤器 12345678910111213&lt;filter&gt; &lt;!--过滤器名，可以随便取，当web应用中有多个过滤器时不允许重名 --&gt; &lt;filter-name&gt;XXXCharaSetFilter&lt;/filter-name&gt; &lt;!-- 具体的过滤器的类的完整的包名+类名。注意：不能写错了。否则容器不能正确的实例化过滤器 --&gt; &lt;filter-class&gt;net.test.CharSetFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;!-- 过滤器名，注意要和上面的&lt;filter-name&gt;里的名字一样 --&gt; &lt;filter-name&gt;XXXCharaSetFilter&lt;/filter-name&gt; &lt;!-- 指定过滤器负责过滤的URL。这里指定了*.jsp表示在访问任何一个jsp页面时都会先使用mypack.SampleFilter过滤器进行过滤。如果写成login.jsp.则只有在访问login.jsp时才会调用该过滤器进行过滤 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 监听器 1234&lt;listener&gt; &lt;!-- 配置会话侦听器，class表示一个HttpSessionListener或 HttpSessionActivationListener 或 HttpSessionAttributeListener或 HttpSessionBindingListener的实现类。该节点允许多个 --&gt; &lt;listener-class&gt;net.test.XXXLisenet&lt;/listener-class&gt;&lt;/listener&gt; 会话(Session)过期时间 1234&lt;session-config&gt; &lt;!-- 设定 HttpSession 的生命周期。时间以分钟为单位 --&gt; &lt;session-timeout&gt;60&lt;/session-timeout&gt;&lt;/session-config&gt; 三、参考文章： web工程中的web.xml文件有什么作用呢？ 一个很详细的web.xml讲解","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"条码的生成与打印输出","date":"2016-08-29T12:11:00.000Z","path":"2016/08/29/net/条码生成与打印/","text":"现如今条码的使用场景相当频繁，今天就让我们来学习一下条码的生成与打印 涉及知识点 zxing的使用 zxing的来由 DLL引用 CODE_128码 DataMatrix码 打印输出 打印工具类 打印机设置 一、zxing的使用zxing的来由zxing 最开始是一个基于Java语言编写的开源类库，用于生成/解析多种格式的1D/2D条码图像处理库，后面提供了多个平台版本的客户端，如本篇用到的.Net版本。 DLL引用 首先去他的官网下载dll文件 添加对应.NET版本的DLL CODE_128码1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 生成二维码/// &lt;/summary&gt;/// &lt;param name=\"data\"&gt;数据源&lt;/param&gt;/// &lt;param name=\"format\"&gt;编码格式&lt;/param&gt;/// &lt;param name=\"width\"&gt;条码宽度&lt;/param&gt;/// &lt;param name=\"height\"&gt;条码高度&lt;/param&gt; public Bitmap generationGraph(string data, BarcodeFormat format, int width, int height) &#123; QrCodeEncodingOptions options = new QrCodeEncodingOptions &#123; // 排错率越高，存储信息越少，但对清晰度要求越低 ErrorCorrection = ErrorCorrectionLevel.H, DisableECI = true, // 设置内容编码 CharacterSet = \"UTF-8\", // 设置二维码宽度 Width = width, // 设置二维码高度 Height = height, // 设置二维码的边距,单位不是固定像素 Margin = 1, //底部显示内容 PureBarcode = false &#125;; BarcodeWriter writer = new BarcodeWriter(); // 设置编码格式 writer.Format = format; writer.Options = options; return writer.Write(data); &#125; 调用:1Bitmap bitmap = generationGraph(\"1234567890987654321\",BarcodeFormat.CODE_128,100,200); DataMatrix码123456789101112131415public Bitmap getDataMatrix(string inputData, int barcodeWidth, int barcodeHeight)&#123; DatamatrixEncodingOptions options = new DatamatrixEncodingOptions() &#123; Width = barcodeWidth,//宽度 Height = barcodeHeight,//高度 Margin = 0, PureBarcode = true, SymbolShape = SymbolShapeHint.FORCE_SQUARE &#125;; options.Hints.Add(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); BarcodeWriter writer = new BarcodeWriter() &#123; Format = BarcodeFormat.DATA_MATRIX, Options = options &#125;; return writer.Write(inputData);&#125; 调用: 1Bitmap bitmap = getDataMatrix(\"1234567890987654321\",100,200); 效果图： 二、打印输出打印工具类条码图片生成了接下来自然就是打印输出到纸张上了，NET 打印方式有很多，这次我们采用 PrintDocument 来输出打印。二话不说，直接上代码！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126namespace Barcode.util&#123; class PrintUtils &#123; public static PrintUtils Instance = new PrintUtils(); private PrintDocument printDocument = null; /// &lt;summary&gt; /// 条码图片 /// &lt;/summary&gt; private Image mBitmpa; /// &lt;summary&gt; /// 纸张宽度 单位定义为毫米mm /// &lt;/summary&gt; public int paperWidth; /// &lt;summary&gt; /// 纸张高度 单位定义为毫米mm /// &lt;/summary&gt; public int paperHeight; private PrintUtils() &#123; printDocument = new PrintDocument(); #region 添加事件监听 printDocument.BeginPrint += new PrintEventHandler(printDocument_BeginPrint); printDocument.PrintPage += new PrintPageEventHandler(printDocument_PrintPage); printDocument.EndPrint += new PrintEventHandler(printDocument_EndPrint); #endregion &#125; #region 设置打印属性设置 /// &lt;summary&gt; /// 设置打印属性 /// &lt;/summary&gt; private void setPrintProperties() &#123; // 设置文档名 printDocument.DocumentName = \"条码打印\";//设置完后可在打印对话框及队列中显示（默认显示document） // 设置选择的打印机名称 printDocument.PrinterSettings.PrinterName = \"TEC B-SX5\"; // 设置纸张大小（可以不设置取，取默认设置） PaperSize ps = new PaperSize(\"Your Paper Name\", (int)(paperWidth / 25.4 * 100), (int)(paperHeight / 25.4 * 100)); ps.RawKind = 150; //如果是自定义纸张，就要大于118 printDocument.DefaultPageSettings.PaperSize = ps; printDocument.DefaultPageSettings.Landscape = true; &#125; #endregion #region 打印机事件监听 #region 打印前事件 /// &lt;summary&gt; /// 打印前事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"e\"&gt;&lt;/param&gt; void printDocument_BeginPrint(object sender, PrintEventArgs e) &#123; //设置打印属性 setPrintProperties(); &#125; #endregion #region 打印输出时(过程)事件 /// &lt;summary&gt; /// 打印输出时(过程)事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"e\"&gt;&lt;/param&gt; void printDocument_PrintPage(object sender, PrintPageEventArgs e) &#123; // 打印输出信息 Graphics g = e.Graphics; g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias; #region 在画布上画图片 g.DrawImage( mBitmpa, new System.Drawing.Rectangle(5, 5, mBitmpa.Width, mBitmpa.Height), new System.Drawing.Rectangle(0, 0, mBitmpa.Width, mBitmpa.Height), System.Drawing.GraphicsUnit.Pixel); #endregion &#125; #endregion #region 打印结束事件 /// &lt;summary&gt; /// 打印结束事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"e\"&gt;&lt;/param&gt; void printDocument_EndPrint(object sender, PrintEventArgs e) &#123; // 打印结束后相关操作 &#125; #endregion #endregion #region 打印预览 /// &lt;summary&gt; /// 打印预览 /// &lt;/summary&gt; /// &lt;param name=\"mBitmpa\"&gt;&lt;/param&gt; public void printPreview(Image mBitmpa, int paperWidth, int paperHeight) &#123; this.mBitmpa = mBitmpa; this.paperWidth = paperWidth; this.paperHeight = paperHeight; PrintPreviewDialog ppd = new PrintPreviewDialog(); ppd.Document = printDocument; ppd.ShowDialog(); &#125; #endregion #region 打印图片 /// &lt;summary&gt; /// 打印图片 /// &lt;/summary&gt; /// &lt;param name=\"mBitmpa\"&gt;图片源&lt;/param&gt; /// &lt;param name=\"mModel\"&gt;配置信息&lt;/param&gt; public void printPicture(Image mBitmpa, int paperWidth, int paperHeight) &#123; this.mBitmpa = mBitmpa; this.paperWidth = paperWidth; this.paperHeight = paperHeight; printDocument.Print(); &#125; #endregion &#125;&#125; 调用:1PrintUtils.Instance.printPreview(this.pictureBox1.Image, pictureBox1.Width, pictureBox1.Height); 打印机设置本次打印机采用 东芝B-SX5，纸张形状为卷状，并且两张之间有间隔。打印机如果未设置好的话，会出现出纸长度不一的现象。","tags":[{"name":"C#","slug":"C","permalink":"https://marklogzhu.github.io/tags/C/"}]}]