[{"title":"hexo","date":"2017-05-24T11:45:00.000Z","path":"2017/05/24/hexo/hexo/","text":"什么是 hexohexo 是博客框架，将支持的类型的文件转换成静态Web页面（html+css+JavaScript）。 常用命令 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate :生成 hexo s == hexo server :启动服务预览 hexo s -p 500 == hexo server :启动服务修改端口为5000预览 hexo d == hexo deploy :部署","tags":[{"name":"hexo","slug":"hexo","permalink":"https://marklogzhu.github.io/tags/hexo/"}]},{"title":"JSP","date":"2017-04-08T08:13:00.000Z","path":"2017/04/08/java/JavaWeb/07.JSP/","text":"一、JSP介绍什么是 JSP？JSP全称是 Java Server Pages，它和 servle 技术一样，都是 SUN 公司定义的一种用于开发动态 web 资源的技术。 JSP 用来干什么？相对于 HTML 只能为用户提供静态数据，Jsp 技术允许在页面中嵌套 java 代码，为用户提供动态数据。实现将内容的生成和信息的展示相分离。 二、JSP 语法在 JSP 中所有 JAVA 语法都可以实现。 &lt;% … %&gt;java代码片段 &lt;%= … %&gt;输出表达式 相当于out.print(); &lt;%! … %&gt;声明成员 &lt;%– 注释内容 –%&gt;JSP 注释 JSP 原理JSP 也是一个 Servlet，当访问 JSP 页面时，服务器会将 JSP 页面转为一个 Servlet。在 Tomcat 服务器的 work\\Catalina\\localhost\\项目名\\org\\apache\\jsp 目录下可以看到转换后的 Servlet 源码。 示例： HelloJsp.jsp12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%-- 声明成员变量 --%&gt; &lt;%!int wage = 2500;%&gt; &lt;%-- 声明成员变量 --%&gt; &lt;% int alimony = 3000; %&gt; &lt;%-- 两者比较 --%&gt; &lt;%=wage &gt; alimony%&gt;&lt;/body&gt;&lt;/html&gt; index_jsp.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;public final class HelloJsp_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent &#123; int wage = 2500; private static final javax.servlet.jsp.JspFactory _jspxFactory = javax.servlet.jsp.JspFactory.getDefaultFactory(); private static java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants; private javax.el.ExpressionFactory _el_expressionfactory; private org.apache.tomcat.InstanceManager _jsp_instancemanager; public java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123; return _jspx_dependants; &#125; public void _jspInit() &#123; _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory(); _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig()); &#125; public void _jspDestroy() &#123; &#125; public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException &#123; final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; try &#123; response.setContentType(\"text/html; charset=UTF-8\"); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(\"\\r\\n\"); out.write(\"&lt;!DOCTYPE html PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\"&gt;\\r\\n\"); out.write(\"&lt;html&gt;\\r\\n\"); out.write(\"&lt;head&gt;\\r\\n\"); out.write(\"&lt;meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"&gt;\\r\\n\"); out.write(\"&lt;title&gt;Insert title here&lt;/title&gt;\\r\\n\"); out.write(\"&lt;/head&gt;\\r\\n\"); out.write(\"&lt;body&gt;\\r\\n\"); out.write(\"\\t\"); out.write('\\r'); out.write('\\n'); out.write(' '); out.write('\\r'); out.write('\\n'); out.write(' '); out.write('\\r'); out.write('\\n'); out.write(' '); int alimony = 3000; out.write('\\r'); out.write('\\n'); out.write(' '); out.write('\\r'); out.write('\\n'); out.write(' '); out.print(wage &gt; alimony); out.write(\"\\r\\n\"); out.write(\"&lt;/body&gt;\\r\\n\"); out.write(\"&lt;/html&gt;\"); &#125; catch (java.lang.Throwable t) &#123; if (!(t instanceof javax.servlet.jsp.SkipPageException))&#123; out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125; if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); &#125; &#125; finally &#123; _jspxFactory.releasePageContext(_jspx_page_context); &#125; &#125;&#125; 三、JSP 指令JSP 指令（directive）是为 JSP 引擎而设计的，它们并不直接产生任何可见输出，而只是告诉引擎如何处理 JSP 页面中的其余部分。 #####格式: &lt;%@指令名称 属性=&quot;值&quot; 属性=&quot;值&quot;%&gt; #####jsp指令分类: * page * include * taglib 注意: 一个页面中可以出现多个指令 指令可以放在任意位置,一般都放在 JSP 页面最上面. page 指令page 指令主要声明 JSP 页面的一些属性 常用属性 contentType设置响应流的编码,及通知浏览器用什么编码打开.设置文件的mimetype pageEncoding设置页面的编码 import导入所需要的包 ontentType和pageEncoding若两者都出现的时候,各自使用各自的编码 若只出现一者,两个都使用出现的这个编码 若两者都不出现,使用服务器默认的编码 tomcat7使用的iso-8859-1 language当前jsp页面里面可以嵌套的语言 buffer设置jsp页面的流的缓冲区的大小 autoFlush是否自动刷新 extends声明当前jsp的页面继承于那个类.必须继承的是httpservlet 及其子类 session设置jsp页面是否可以使用session内置对象 isELIgnored是否忽略el表达式 errorPage当前jsp页面出现异常的时候要跳转到的jsp页面 isErrorPage当前jsp页面是否是一个错误页面,若值为true,可以使用jsp页面的一个内置对象 exception include 指令静态包含,就是将其他页面或者servlet的内容包含进来,一起进行编译运行.生成一个java文件.格式: &lt;%@include file=&quot;相对路径或者是内部路径&quot; %&gt; taglib指令导入标签库，格式: &lt;%@taglib prefix=&quot;前缀名&quot; uri=&quot;名称空间&quot; %&gt; 使用格式： &lt;前缀名:标签 .. &gt; 四、JSP 九大内置对象JSP 引擎在调用 JSP 对应的 _jspServlet 时，会传递或创建9个与 web 开发相关的对象供 _jspServlet使用。 NO 内置对象 类型 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable pageContext 对象pageContext 对象是JSP技术中最重要的一个对象，它代表 JSP 页面的运行环境，这个对象不仅封装了对其它 8 大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了 web 开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。 通过 pageContext 获得其他对象 * getException 方法返回 exception 隐式对象 * getPage 方法返回 page 隐式对象 * getRequest 方法返回 request 隐式对象 * getResponse 方法返回 response 隐式对象 * getServletConfig 方法返回 config 隐式对象 * getServletContext 方法返回 application 隐式对象 * getSession 方法返回 session 隐式对象 * getOut 方法返回 out 隐式对象 pageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。常用方法： void setAttribute(java.lang.String name,java.lang.Object value)注册使用页面范围语义指定的名称和值。如果传入的值为 null，则调用此方法与调用 removeAttribute( name, PageContext.PAGE_SCOPE ) 产生的效果相同。 java.lang.Object getAttribute(java.lang.String name)从所有范围中移除与给定名称关联的对象引用。如果没有此类对象，则不执行任何操作。 void removeAttribute(java.lang.String name)从所有范围中移除与给定名称关联的对象引用。如果没有此类对象，则不执行任何操作。 java.lang.Object findAttribute(java.lang.String name)按顺序在页面、请求、会话（如果有效）和应用程序范围中搜索指定属性，并返回关联的值或 null。 out 对象out 对象用于向客户端发送文本数据。out 对象是通过调用 pageContext 对象的 getOut 方法返回的，其作用和用法与 ServletResponse.getWriter 方法返回的 PrintWriter 对象非常相似。 page 对象page对象表示当前一个 JSP 页面，可以理解为一个对象本身，即：把一个 JSP 当作一个对象来看待。page 对象在开发中几乎不用，了解一下即可 示例:123456789101112131415161718&lt;%--设置属性 --%&gt;&lt;% pageContext.setAttribute(\"name\", \"且听风吟\"); request.setAttribute(\"value1\", 1); application.setAttribute(\"value2\", 2); session.setAttribute(\"value3\", 3);%&gt;&lt;%-- 获取属性 --%&gt;name:&lt;%=pageContext.getAttribute(\"name\")%&gt;&lt;br&gt;value1:&lt;%=pageContext.findAttribute(\"value1\")%&gt;&lt;br&gt;value2:&lt;%=pageContext.findAttribute(\"value2\")%&gt;&lt;br&gt;value3:&lt;%=pageContext.findAttribute(\"value3\")%&gt;&lt;br&gt;&lt;%--查找一个没有的属性 --%&gt;value4:&lt;%=pageContext.findAttribute(\"value4\")%&gt; 五、JSP 属性范围所谓的属性范围就是一个属性设置之后，可以经过多少个其他页面后仍然可以访问的保存范围。范围分类： 当前页：一个属性只能在一个页面中取得，跳转到其他页面无法取得 一次服务器请求：一个页面中设置的属性，只要经过了服务器跳转，则跳转之后的页面可以继续取得。 一次会话：一个用户设置的内容，只要是与此用户相关的页面都可以访问（一个会话表示一个人，这个人设置的东西只要这个人不走，就依然有效） 上下文中：在整个服务器上设置的属性，所有人都可以访问 以下四个对象作用域： * application 整个项目 * session 一次会话 * request 一次请求 * pageContext 一个页面 六、JSP 标签JSP 标签也称之为 Jsp Action(JSP动作)元素，它用于在 JSP 页面中提供业务逻辑功能，避免在 JSP 页面中直接编写 JAVA 代码，造成 JSP 页面难以维护。 JSP 的常用标签: * &lt;jsp:include&gt;标签 * &lt;jsp:forward&gt;标签 * &lt;jsp:param&gt;标签 &lt; jsp:include &gt;标签此标签用于把另外一个资源的输出内容插入进当前 JSP 页面的输出内容之中，这种在JSP页面执行时的引入方式称之为动态引入。语法： &lt;jsp:include page=&quot;relativeURL | &lt;%=expression%&gt;&quot; flush=&quot;true|false&quot; /&gt; page 属性用于指定被引入资源的相对路径，它也可以通过执行一个表达式来获得。flush 属性指定在插入其他资源的输出内容时，是否先将当前JSP页面的已输出的内容刷新到客户端。 &lt; jsp:include&gt;标签与include指令的区别 &lt; jsp:include&gt; 标签是动态引入， 标签涉及到的2个JSP页面会被翻译成2个servlet，这2个servlet的内容在执行时进行合并。 而include指令是静态引入，涉及到的2个JSP页面会被翻译成一个servlet，其内容是在源文件级别进行合并。 示例： 1234567891011121314 &lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;jsp的jsp:include标签测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%--使用jsp:include标签引入其它JSP页面--%&gt; &lt;jsp:include page=\"/head.jsp\"/&gt; &lt;h1&gt;网页主体内容&lt;/h1&gt; &lt;jsp:include page=\"/foot.jsp\"/&gt; &lt;/body&gt;&lt;/html&gt; ###&lt; jsp:forward&gt;标签 &lt; jsp:forward&gt;标签用于把请求转发给另外一个资源。语法： &lt;jsp:forward page=&quot;relativeURL | &lt;%=expression%&gt;&quot; /&gt; page属性用于指定请求转发到的资源的相对路径，它也可以通过执行一个表达式来获得。 示例：123&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;%--使用&lt;jsp:forward&gt;标签跳转到forwarddemo02.jsp--%&gt;&lt;jsp:forward page=\"/forwarddemo02.jsp\"/&gt; &lt; jsp:param&gt;标签当使用&lt; jsp:include&gt; 和 &lt; jsp:forward&gt; 标签引入或将请求转发给其它资源时，可以使用 &lt; jsp:param&gt; 标签向这个资源传递参数。语法1： 123&lt;jsp:include page=\"relativeURL | &lt;%=expression%&gt;\"&gt; &lt;jsp:param name=\"parameterName\" value=\"parameterValue|&lt;%= expression %&gt;\" /&gt;&lt;/jsp:include&gt; 语法2：123&lt;jsp:forward page=\"relativeURL | &lt;%=expression%&gt;\"&gt; &lt;jsp:param name=\"parameterName\" value=\"parameterValue|&lt;%= expression %&gt;\" /&gt;&lt;/jsp:include&gt; &lt; jsp:param&gt;标签的 name 属性用于指定参数名，value 属性用于指定参数值。在&lt; jsp:include&gt;和&lt; jsp:forward&gt;标签中可以使用多个&lt; jsp:param&gt;标签来传递多个参数。","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Hibernate 框架","date":"2017-04-07T13:34:00.000Z","path":"2017/04/07/java/Hibernate/01.Hibernate/","text":"一、Hibernate 简介在了解 Hibernate 之前，我们先了解下什么是 ORM 。 1.1 ORM 概述ORM 全称为 Object Relational Mapping，翻译过来就是对象关系映射 * O：面向对象领域的 Object（JavaBean对象） * R：关系数据库领域的 Relational（表的结构） * M：映射 Mapping（XML的配置文件） 1.2 什么是 HibernateHibernate 是一个开放源代码的对象关系映射框架。它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架。 1.3 Hibernate 能干什么 自动生成 SQL 语句并执行 数据持久化 1.4 Hibernate 优点 Hibernate 对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 Hibernate是一个基于 JDBC 的主流持久化框架，是一个优秀的 ORM 实现，它很大程度的简化了 DAO 层编码工作 Hibernate 的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 简单来说，Hibernate 框架就是使我们可以通过操作对象的方式操作数据库。 二、Hibernate 环境搭建1.1 下载 Hibernate 开发包Hibernate开发包 1.2 Hibernate 包结构说明1.2 eclipse 搭建将","tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://marklogzhu.github.io/tags/JAVA/"}]},{"title":"会话技术之 Cookie 和 Session","date":"2017-04-07T13:34:00.000Z","path":"2017/04/07/java/JavaWeb/06.会话技术之Cookie和Session/","text":"一、会话会话是什么？会话可简单理解为：用户开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学曾经来过，这称之为有状态会话。 会话用来干什么？保存浏览器与服务器通信时产生的数据 有哪些会话技术？ Cookie Cookie 是客户端技术，程序把每个用户的数据以 cookie 的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。 Session Session 是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的 session 对象，由于 session 为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的 session 中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的 session 中取出数据为用户服务。 Cookie 与 Session的区别 Cookie 是把数据写给浏览器。 Session 把数据写到每一个浏览器对应的独占 session 中。 Session 对象由服务器创建，开发人员可以调用 request 对象的 getSession 方法得到session对象。 二、常用方法Cookie 常用方法 Cookie(String name, String value)构造带指定名称和值的 cookie,cookie 的名称在创建之后不得更改。 void setComment(String purpose)指定一个 cookie 用途的注释。 String getComment()返回描述此 cookie 用途的注释；如果该 cookie 没有注释，则返回 null。 setDomain(String pattern)指定应在其中显示此 cookie 的域。 String getDomain()返回为此 cookie 设置的域名。 void setMaxAge(int expiry)设置 cookie 的最大生存时间，以秒为单位。0 值会导致删除 cookie。 int getMaxAge()返回以秒为单位指定的 cookie 的最大生存时间，默认情况下，-1 指示该 cookie 将保留到浏览器关闭为止。 setPath(String uri)设置cookie 的路径。 String getPath()返回浏览器将此 cookie 返回到的服务器上的路径。 void setSecure(boolean flag)指示浏览器是否只能使用安全协议（如 HTTPS 或 SSL）发送 cookie。 boolean getSecure()如果浏览器仅通过安全协议发送 cookie，则返回 true；如果浏览器可以使用任何协议发送 cookie，则返回 false。 String getName()返回 cookie 的名称。名称在创建之后不得更改。 void setValue(String newValue)在创建 cookie 之后将新值分配给 cookie String getValue()返回 cookie 的值。 int getVersion()返回此 cookie 遵守的协议版本。 void setVersion(int v)设置此 cookie 遵守的 cookie 协议版本。 clone()重写标准 java.lang.Object.clone 方法以返回此 cookie 的副本。 Session 常用方法 long getCreationTime()返回创建此会话的时间 String getId()返回包含分配给此会话的唯一标识符的字符串 long getLastAccessedTime()返回客户端上一次发送与此会话关联的请求的时间 ServletContext getServletContext()返回此会话所属的 ServletContext void setMaxInactiveInterval(int interval)指定在 servlet 容器使此会话失效之前客户端请求之间的时间间隔，以秒为单位。负数时间指示会话永远不会超时。 int getMaxInactiveInterval()返回 servlet 容器在客户端访问之间将使此会话保持打开状态的最大时间间隔，以秒为单位。 Object getAttribute(String name)返回与此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回 null。 java.util.Enumeration getAttributeNames()返回包含绑定到此会话的所有对象的名称的 String 对象的 Enumeration。 void setAttribute(String name, Object value)使用指定名称将对象绑定到此会话。如果具有同样名称的对象已经绑定到该会话，则替换该对象。 void removeAttribute(String name)从此会话中移除与指定名称绑定在一起的对象。如果会话没有与指定名称绑定在一起的对象，则此方法不执行任何操作。 void invalidate()使此会话无效，然后取消对任何绑定到它的对象的绑定。 boolean isNew()如果客户端还不知道该会话，或者客户端选择不加入该会话，则返回 true。例如，如果服务器仅使用基于 cookie 的会话，而客户端已经禁止了 cookie 的使用，则每个请求上的会话都将是新会话。 三、编码实践 获取上一次访问时间 123456789101112131415161718192021222324252627private static final String LAST_ACCESS_TIME = \"lastAccessTime\";protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置输出字符集 response.setCharacterEncoding(\"utf-8\"); // 获取输出流 PrintWriter writer = response.getWriter(); // 获取Cookie数组 Cookie[] cookies = request.getCookies(); if (cookies == null) &#123; writer.write(\"第一次访问...\"); &#125; else &#123; writer.write(\"上次访问时间为：\"); for (Cookie cookie : cookies) &#123; if (LAST_ACCESS_TIME.equals(cookie.getName())) &#123; Long lastAccessTime = Long.parseLong(cookie.getValue()); Date date = new Date(lastAccessTime); java.text.DateFormat format1 = new java.text.SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); writer.write(format1.format(date)); &#125; &#125; &#125; Cookie cookie = new Cookie(LAST_ACCESS_TIME, \"\" + System.currentTimeMillis()); response.addCookie(cookie);&#125; ####结果： 第一次访问： 第二次访问： cookie中存取中文 12Cookie cookie = new Cookie(\"userName\", URLEncoder.encode(\"且听风吟\", \"UTF-8\"));response.addCookie(cookie); cookie中获取中文 1URLDecoder.decode(cookie.getValue(), \"UTF-8\") session 基本使用 1服务器创建 session 出来后，会把 session 的id号，以 cookie 的形式回写给客户机，这样，只要客户机的浏览器不关，再去访问服务器时，都会带着 session 的 id 号去，服务器发现客户机浏览器带 session id 过来了，就会使用内存中与之对应的 session 为之服务。 12345678910111213141516171819protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置编码格式 response.setCharacterEncoding(\"UTF-8\"); // 获取输出流 PrintWriter writer = response.getWriter(); // 获取Session,若没有则新建 HttpSession session = request.getSession(); // 设置值 session.setAttribute(\"name\", \"且听风吟\"); // 获取SessionId String sessionId = session.getId(); // 判断是否第一次创建Session if (session.isNew()) &#123; writer.print(\"第一次创建Session，id为:\" + sessionId); &#125; else &#123; writer.print(\"已存在Session，id为:\" + sessionId); &#125;&#125; 结果： 四、注意Cookie 在读取Cookie，然后操作时，除了getName(),getValue()外，不要妄图得到其他信息，其他方法不会得到值的 一个Cookie只能标识一种信息，它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。 一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。 浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。 Session session对象的创建时机在程序中第一次调用request.getSession()方法时就会创建一个新的Session，可以用isNew()方法来判断Session是不是新创建的 session对象的销毁时机session对象默认30分钟没有使用，则服务器会自动销毁session，在web.xml文件中可以手工配置session的失效时间.如：1234&lt;!-- 设置Session的有效时间:以分钟为单位--&gt;&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt; 当需要在程序中手动设置Session失效时，可以手工调用session.invalidate方法，摧毁session。123HttpSession session = request.getSession();// 手工调用session.invalidate方法，摧毁sessionsession.invalidate();","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Servlet之response","date":"2017-03-31T13:00:00.000Z","path":"2017/03/31/java/JavaWeb/05.Servlet之response/","text":"一、Response简介Response是什么？Request代表着一个 HTTP 响应对象，里面存放着 HTTP 的响应消息 什么时候被创建？当调用 Servlet 的 service() 方法时创建 谁创建？由Servlet容器创建 能干什么向客户端输出数据 Response的层次结构-- javax.servlet.ServletResponse -- javax.servlet.http.HttpServletResponse 二、常用方法 负责向客户端(浏览器)发送数据的相关方法 ServletOutputStream getOutputStream()返回适用于在响应中编写二进制数据的 ServletOutputStream PrintWriter getWriter()返回可将字符文本发送到客户端的 PrintWriter 对象,默认字符集为 ISO-8859-1 负责向客户端(浏览器)发送响应头的相关方法 void addCookie(Cookie cookie)添加 Cookie 对象，同名的 Cookie 会覆盖 void addDateHeader(String name, long date)以 KEY_VALUE 的形式添加日期响应头 void addHeader(String name, String value)以 KEY_VALUE 的形式添加响应头 负责向客户端(浏览器)发送响应状态码的相关方法 void setStatus(int sc)设置响应状态码 响应状态码的常量 int SC_OK 200:正常响应 int SC_NOT_FOUND 404:用户操作错误 int SC_METHOD_NOT_ALLOWED405:访问的方法不存在 int SC_INTERNAL_SERVER_ERROR500:内部错误 三、编码实践 使用 getWriter() 向页面输出汉字 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(\"utf-8\"); PrintWriter writer = response.getWriter(); writer.print(\"且听风吟,且待琴终。\"); writer.close();&#125; 结果： 使用 getOutputStream() 向页面输出汉字 123456789protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String data = \"且听风吟,且待琴终。\"; // 通过设置响应头控制浏览器以UTF-8的编码显示数据 response.setHeader(\"content-type\", \"text/html;charset=UTF-8\"); ServletOutputStream out = response.getOutputStream(); out.write(data.getBytes(\"UTF-8\")); out.close();&#125; 结果： ![](http://oajxivjud.bkt.clouddn.com/responseDemo01.png) 文件下载 1234567891011121314151617181920212223protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.获取要下载的文件的绝对路径 String realPath = this.getServletContext().getRealPath(\"/download/中文文件名.TXT\"); // 2.获取要下载的文件名 String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); // 3.设置content-disposition响应头控制浏览器以下载的形式打开文件,注意中文文件名要转码 response.setHeader(\"content-disposition\", \"attachment;filename=\" + URLEncoder.encode(fileName, \"UTF-8\")); // 4.获取要下载的文件输入流 InputStream in = new FileInputStream(realPath); int len = 0; // 5.创建数据缓冲区 byte[] buffer = new byte[1024]; // 6.通过response对象获取OutputStream流 OutputStream out = response.getOutputStream(); // 7.将FileInputStream流写入到buffer缓冲区 while ((len = in.read(buffer)) &gt; 0) &#123; // 8.使用OutputStream将缓冲区的数据输出到客户端浏览器 out.write(buffer, 0, len); &#125; in.close();&#125; 结果： 注：下载文件时避免使用 PrintWriter 流，因为 PrintWriter 流是字符流，只能处理字符数据，会导致数据丢失。而 OutputStream 流是字节流，可以处理任何数据，所以下载文件要使用 OutputStream 流。 生成随机数字验证码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setHeader(&quot;refresh&quot;, &quot;5&quot;);// 设置refresh响应头控制浏览器每隔5秒钟刷新一次 // 1.在内存中创建一张图片 BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB); // 2.得到图片 Graphics2D g = (Graphics2D) image.getGraphics(); g.setColor(Color.WHITE);// 设置图片的背景色 g.fillRect(0, 0, 80, 20);// 填充背景色 // 3.向图片上写数据 g.setColor(Color.BLUE);// 设置图片上字体的颜色 g.setFont(new Font(null, Font.BOLD, 20)); g.drawString(getRandomCode(), 0, 20); // 4.设置响应头控制浏览器浏览器以图片的方式打开 response.setContentType(&quot;image/jpeg&quot;); // 等同于response.setHeader(&quot;Content-Type&quot;,&quot;image/jpeg&quot;); // 5.设置响应头控制浏览器不缓存图片数据 response.setDateHeader(&quot;expries&quot;, -1); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); // 6.将图片写给浏览器 ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream()); } 12345private String getRandomCode() &#123; Random ran = new Random(); String num = (ran.nextInt(8999999) + 1000000) + \"\"; return num;&#125; 结果： ![](http://oajxivjud.bkt.clouddn.com/RandomCode.gif) 设置响应头控制浏览器的行为 设置http响应头控制浏览器禁止缓存当前文档内容 123 response.setDateHeader(\"expries\", -1);response.setHeader(\"Cache-Control\", \"no-cache\");response.setHeader(\"Pragma\", \"no-cache\"); 设置http响应头控制浏览器定时刷新网页(refresh) 12//设置refresh响应头控制浏览器每隔5秒钟刷新一次response.setHeader(\"refresh\", \"5\"); 通过response实现请求重定向 请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。 应用场景：用户登陆，用户首先访问登录页面，登录成功后，就会跳转到某个页面，这个过程就是一个请求重定向的过程 实现方式：response.sendRedirect(String location)，即调用 response 对象的 sendRedirect 方法实现请求重定向 sendRedirect内部的实现原理：使用 response 设置 302 状态码和设置location响应头实现重定向 1234 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.sendRedirect(\"/day01_Servlet/hello.html\");&#125;","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Servlet之request","date":"2017-03-30T13:00:00.000Z","path":"2017/03/30/java/JavaWeb/04.Servlet之request/","text":"一、Request简介Request是什么？Request代表着一个HTTP请求对象，里面存放着请求参数和属性。 什么时候被创建？当调用 Servlet 的 service() 方法时创建 谁创建？由Servlet容器创建，这个对象自动封装了请求方式及参数等信息 能干什么可以找到请求从哪里发出，请求什么资源，带什么参数，获取Session对象和客户端的Cookie ServletRequest的层次结构-- javax.servlet.ServletRequest -- javax.servlet.http.HttpServletRequest 二、常用方法 void setAttribute(String name,Object o)以 KEY-VLUE 的形式设置属性 Object getAttribute(String name)以 Object 形式返回指定属性的值，如果不存在给定名称的属性，则返回 null。 void removeAttribute(String name)移除指定属性 Enumeration getAttributeNames()返回包含此请求可用属性的名称的 Enumeration。如果该请求没有可用的属性，则此方法返回一个空的 Enumeration void setCharacterEncoding(String env)设置请求正文编码字符集 String getCharacterEncoding()获取请求正文编码字符集 String getContentType()获取返回请求主体的MIME类型 String getParameter(String name)以 String 形式返回请求参数的值，如果该参数不存在，则返回 null String[] getParameterValues(String name)返回包含给定请求参数拥有的所有值的 String 对象数组，如果该参数不存在，则返回 null String getMethod()获取请求的 HTTP 方法的名称，例如GET，POST或PUT String getRequestURI()获取请求URI,获取的是 从项目名到参数之前的内容 StringBuffer getRequestURL()获取请求URL,获取的带协议的完整路径 String getQueryString()get请求的所有参数 String getProtocol()获取协议和版本 String getScheme()获取请求方案名称，如 http、https 或 ftp String getServerName()获取包含服务器名称的 String，如 IP 地址 int getServerPort()获取服务器端口号 String getRemoteAddr()获取客户端IP地址 java.util.Locale getLocale()基于 Accept-Language 头，返回客户端将用来接受内容的首选 Locale boolean isSecure()返回一个 boolean 值，指示此请求是否是使用安全通道（比如 HTTPS）发出的 三、编码实践 属性设置、获取、移除 1234567protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String tag = \"name\"; request.setAttribute(tag, \"张三\"); System.out.println(tag + request.getAttribute(tag)); request.removeAttribute(tag); System.out.println(tag + request.getAttribute(tag));&#125; 结果： 12name:张三name:null 字符集的获取与设置 12345protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"正文编码字符集：\" + request.getCharacterEncoding()); request.setCharacterEncoding(\"utf-8\"); System.out.println(\"正文编码字符集：\" + request.getCharacterEncoding());&#125; 结果： 12正文编码字符集：null正文编码字符集：utf-8 获取客户端信息 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"客户端IP地址：\" + request.getRemoteAddr()); System.out.println(\"请求方式：\" + request.getScheme()); System.out.println(\"是否是HTTPS请求：\" + request.isSecure()); System.out.println(\"请求方式：\" + request.getMethod());&#125; 结果： 1234客户端IP地址：0:0:0:0:0:0:0:1请求方式：http是否是HTTPS请求：false请求方式：GET 获取服务端信息 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"服务器端口号：\" + request.getServerPort()); System.out.println(\"服务器名称：\" + request.getServerName()); System.out.println(\"项目名称：\" + request.getContextPath());&#125; 结果： 123服务器端口号：8888服务器名称：localhost项目名称：/day01_Servlet 获取请求消息12345678protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"不带协议路径：\" + request.getRequestURI()); System.out.println(\"带协议路径：\" + request.getRequestURL()); System.out.println(\"请求方式：\" + request.getMethod()); System.out.println(\"get请求的所有参数:\" + request.getQueryString()); System.out.println(\"协议和版本：\" + request.getProtocol());&#125; 结果： 12345不带协议路径：/day01_Servlet/request带协议路径：http://localhost:8888/day01_Servlet/request请求方式：GETget请求的所有参数:null协议和版本：HTTP/1.1","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Servlet之ServletConfig与ServletContext对象","date":"2017-03-19T13:00:00.000Z","path":"2017/03/19/java/JavaWeb/03.Servlet之ServletConfig和ServletContext对象/","text":"在 Servlet之生命周期 中我们除了提到三个生命周期方法之外，还提到了二个方法 getServletConfig()和getServletInfo()，他返回的对象分别是ServletConfig和ServletContext对象，今天就让我们来学习下这两个对象 一、ServletConfig简介官方定义：A servlet configuration object used by a servlet container to pass information to a servlet during initialization.中文翻译：一个servlet的配置对象，用来给servlet容器传递信息到servlet，在Servlet初始化的时候。 简单来说 ServletConfig 就是一个配置对象，通过它可以很方便的获取 web.xml 中配置的信息 二、ServletConfig常用方法* String getInitParameter(java.lang.String name) 作用：返回一个包含指定初始化参数值的字符串，如果参数不存在，则返回null。 * Enumeration&lt;String&gt; getInitParameterNames() 作用： 返回servlet的初始化参数的名称作为String对象的枚举，如果servlet没有初始化参数，则返回空枚举。 * ServletContext getServletContext() 作用：返回对调用者正在执行的ServletContext的引用。 * String getServletName() 作用：获取servlet实例的名称 三、编码实践 1.编写Servlet类 12345678910111213141516171819202122232425262728import java.io.IOException;import java.util.Enumeration;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletConfigDemo extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.getServletConfig() ServletConfig config = this.getServletConfig(); // 2.getServletName() System.out.println(\"ServletName:\" + config.getServletName()); // 3.getInitParameter() System.out.println(\"大写KEY值:\" + config.getInitParameter(\"NAME\")); System.out.println(\"小写KEY值:\" + config.getInitParameter(\"name\")); // 4.getInitParameterNames() Enumeration&lt;String&gt; enumeration = config.getInitParameterNames(); while (enumeration.hasMoreElements()) &#123; String name = enumeration.nextElement(); String value = config.getInitParameter(name); System.out.println(\"name-----------&gt;\" + name); System.out.println(\"value-----------&gt;\" + value); &#125; &#125;&#125; 2.编写web.xml配置 1234567891011121314&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;ServletConfigDemo&lt;/display-name&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mark.day01.ServletConfigDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;markLogZhu&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletConfig&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.运行，查看结果 4.注 例子中 getInitParameter() 方法的 key 参数为大写，而 web.xml 中 key 为小写，可以看到返回的值为null，证明参数区分大小写 四、ServletContext简介在整个web应用中，只有一个ServletContext，WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。当项目被移除的时候或者服务器关闭的时候servletcontext也同时被销毁 五、ServletContext的常用方法 1.获取ServletContext实例 方式一： 1ServletContext servletContext = this.getServletContext(); 方式二： 1ServletContext servletContext = this.getServletConfig().getServletContext(); 2.利用ServletContext实现数据共享 写数据 12ServletContext servletContext = config.getServletContext();servletContext.setAttribute(\"name\", \"markLogZhu\"); 读数据 12ServletContext servletContext = getServletConfig().getServletContext(); System.out.println(\"value:\"+servletContext.getAttribute(\"name\")); 3.获取 web.xml 配置信息(跟 ServletConfig 对象的 getInitParameterNames()方法一样) web.xml配置 1234567891011121314&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;ServletConfigDemo&lt;/display-name&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mark.day01.ServletConfigDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;markLogZhu&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletConfig&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 获取配置信息 12345678ServletContext context = this.getServletContext();Enumeration enumeration = context.getInitParameterNames();while(enumeration.hasMoreElements())&#123; String name = (String) enumeration.nextElement(); String value = (String) context.getInitParameter(name); System.out.println(\"name：\"+name); System.out.println(\"value：\"+value.toString());&#125; 4.Servlet的转发 Servlet类 12345 ServletContext context = this.getServletContext(); //在request设置参数，然后在jsp界面中获取。 req.setAttribute(\"name\", \"value\");RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/index.jsp\");requestDispatcher.forward(req,resp); jsp界面获取数据： 1234&lt;% String value = (String)request.getAttribute(\"name\"); System.out.println(\"value：\"+value);%&gt; 5.读取资源的配置文件 123456789101112ServletContext context = this.getServletContext();InputStream inputStream = context.getResourceAsStream(\"/db.properties\");ByteArrayOutputStream outStream = new ByteArrayOutputStream();byte[] by = new byte[1024];int len = 0;while((len = inputStream.read(by))!= -1)&#123; outStream.write(by, 0, len);&#125;String content = new String(outStream.toByteArray());System.out.println(\"content：\"+content);outStream.close();inputStream.close(); 六、参考：java_web学习第二天(ServletConfig和ServletContext对象的作用和使用)","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"Servlet之生命周期","date":"2017-03-19T10:10:00.000Z","path":"2017/03/19/java/JavaWeb/02.Servlet之生命周期/","text":"一、Servlet简介JavaServlet 是用 Java 语言编写的服务端程序。其主要功能是接收和响应客户端的请求。 二、Servlet结构-- Servlet 接口 -- GenericServlet 抽象类 -- HttpServlet 抽象类 -- 自定义业务Servlet 业务类 三、Servlet接口方法=======================生命周期方法开始====================================== * void init(ServletConfig config) 作用：初始化方法 调用者：服务器 调用时机：默认第一次访问的时候或load-on-startup中设置正整数值时(值越大优先级越低) 调用次数：一次 * void service(ServletRequest req, ServletResponse res) 作用：处理业务逻辑方法 调用者：服务器 调用时机：请求来的时候 调用次数：请求来一次调用一次 * void destroy() 作用：初始化方法 调用者：服务器 调用时机：Service被移除或服务器正常关闭时 调用次数：一次 =======================生命周期方法结束====================================== * ServletConfig getServletConfig() 作用：获得任何初始化和启动参数信息 * String getServletInfo() 作用：获取有关其自身的基本信息，比如作者、版本和版权 四、编码实践Servlet生命周期 1.编写类 123456789101112131415161718192021222324252627282930313233import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class LifeServlet implements Servlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println(\"init()调用\"); &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(\"service()调用\"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; System.out.println(\"destroy()调用\"); &#125;&#125; 2.配置web.xml文件(若new类为Servlet，IDE默认已配置，可跳过此步) 12345678910&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;LifeServlet&lt;/display-name&gt; &lt;servlet-name&gt;LifeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mark.day01.LifeServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LifeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/life&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.启动Tomcat 4.按步骤操作对照结果 4.1 在浏览器中输入项目地址(http://localhost:8888/day01_Servlet/life) 注1：因笔者电脑中先安装了 IIS，后安装 Tomcat，所以为了解决端口冲突所以将端口设为8888 注2：每个人的项目名称和包名不同，请按自己的实际项目修改web.xml跟浏览器地址 4.2 查看控制器输出 4.3 在浏览器中刷新页面，然后查看控制器输出 可以发现service方法又一次被调用了，而init()方法只在第一次访问时调用 4.4 关闭Tomcat,查看控制器输出 注： 五、总结serlvet是一个单实例多线程对象，默认第一次访问的时候,服务器创建servlet,并调用init实现初始化操作.并调用一次service方法。每当请求来的时候,服务器创建一个线程,调用service方法执行自己的业务逻辑。当serlvet被移除的时候服务器正常关闭的时候,服务器调用servlet的destroy方法实现销毁操作.","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"web.xml","date":"2017-03-19T03:11:00.000Z","path":"2017/03/19/java/JavaWeb/01.web,xml/","text":"一、web.xml简介web.xml是JavaWeb项目的配置文件，主要用来配置欢迎页、servlet、filter等信息，如果你的项目不需要配置这些信息的话，也可以不创建这个文件 二、常用标签 指定欢迎页面 1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index1.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 注：指定两个欢迎页，如果index.jsp不存在就寻找index1.jsp 命名与定制URL(如：Servlet和JSP) 命名 123456&lt;servlet&gt; &lt;!-- Servlet名字，可以随便取，有多个Servlet时不允许重名 --&gt; &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt; &lt;!-- 指定实现这个Servlet的类。完整的包名+类名 --&gt; &lt;servlet-class&gt;net.test.TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt; 定义URL 123456&lt;servlet-mapping&gt; &lt;!--必须和&lt;servlet&gt;里的&lt;servlet-name&gt;内容一样--&gt; &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt; &lt;!-- 指定访问这个Servlet的URL。这里给出的是对于整个Web应用的相对URL路径 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt; /servlet-mapping&gt; 定制初始化参数 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt; &lt;servlet-class&gt;net.test.TestServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 参数名 --&gt; &lt;param-name&gt;E-mail&lt;/param-name&gt; &lt;!-- 参数值 --&gt; &lt;param-value&gt;Tommy@163.com&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;userName&lt;/param-name&gt; &lt;param-value&gt;Tommy&lt;/param-value&gt; &lt;/init-param&gt;&lt; /servlet&gt; 在Servlet类中取值：getServletConfig().getInitParameter(&quot;E-mail&quot;) 指定错误处理页面 12345&lt;!-- 错误码 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error404.jsp&lt;/location&gt;&lt;/error-page&gt; 12345&lt;!-- 异常类型 --&gt;&lt;error-page&gt; &lt;exception-type&gt;Java.lang.Exception&lt;exception-type&gt; &lt;location&gt;/exception.jsp&lt;location&gt;&lt;/error-page&gt; 过滤器 12345678910111213&lt;filter&gt; &lt;!--过滤器名，可以随便取，当web应用中有多个过滤器时不允许重名 --&gt; &lt;filter-name&gt;XXXCharaSetFilter&lt;/filter-name&gt; &lt;!-- 具体的过滤器的类的完整的包名+类名。注意：不能写错了。否则容器不能正确的实例化过滤器 --&gt; &lt;filter-class&gt;net.test.CharSetFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;!-- 过滤器名，注意要和上面的&lt;filter-name&gt;里的名字一样 --&gt; &lt;filter-name&gt;XXXCharaSetFilter&lt;/filter-name&gt; &lt;!-- 指定过滤器负责过滤的URL。这里指定了*.jsp表示在访问任何一个jsp页面时都会先使用mypack.SampleFilter过滤器进行过滤。如果写成login.jsp.则只有在访问login.jsp时才会调用该过滤器进行过滤 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 监听器 1234&lt;listener&gt; &lt;!-- 配置会话侦听器，class表示一个HttpSessionListener或 HttpSessionActivationListener 或 HttpSessionAttributeListener或 HttpSessionBindingListener的实现类。该节点允许多个 --&gt; &lt;listener-class&gt;net.test.XXXLisenet&lt;/listener-class&gt;&lt;/listener&gt; 会话(Session)过期时间 1234&lt;session-config&gt; &lt;!-- 设定 HttpSession 的生命周期。时间以分钟为单位 --&gt; &lt;session-timeout&gt;60&lt;/session-timeout&gt;&lt;/session-config&gt; 三、参考文章： web工程中的web.xml文件有什么作用呢？ 一个很详细的web.xml讲解","tags":[{"name":"JAVA WEB","slug":"JAVA-WEB","permalink":"https://marklogzhu.github.io/tags/JAVA-WEB/"}]},{"title":"条码的生成与打印输出","date":"2016-08-29T12:11:00.000Z","path":"2016/08/29/net/条码生成与打印/","text":"现如今条码的使用场景相当频繁，今天就让我们来学习一下条码的生成与打印 涉及知识点 zxing的使用 zxing的来由 DLL引用 CODE_128码 DataMatrix码 打印输出 打印工具类 打印机设置 一、zxing的使用zxing的来由zxing 最开始是一个基于Java语言编写的开源类库，用于生成/解析多种格式的1D/2D条码图像处理库，后面提供了多个平台版本的客户端，如本篇用到的.Net版本。 DLL引用 首先去他的官网下载dll文件 添加对应.NET版本的DLL CODE_128码1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 生成二维码/// &lt;/summary&gt;/// &lt;param name=\"data\"&gt;数据源&lt;/param&gt;/// &lt;param name=\"format\"&gt;编码格式&lt;/param&gt;/// &lt;param name=\"width\"&gt;条码宽度&lt;/param&gt;/// &lt;param name=\"height\"&gt;条码高度&lt;/param&gt; public Bitmap generationGraph(string data, BarcodeFormat format, int width, int height) &#123; QrCodeEncodingOptions options = new QrCodeEncodingOptions &#123; // 排错率越高，存储信息越少，但对清晰度要求越低 ErrorCorrection = ErrorCorrectionLevel.H, DisableECI = true, // 设置内容编码 CharacterSet = \"UTF-8\", // 设置二维码宽度 Width = width, // 设置二维码高度 Height = height, // 设置二维码的边距,单位不是固定像素 Margin = 1, //底部显示内容 PureBarcode = false &#125;; BarcodeWriter writer = new BarcodeWriter(); // 设置编码格式 writer.Format = format; writer.Options = options; return writer.Write(data); &#125; 调用:1Bitmap bitmap = generationGraph(\"1234567890987654321\",BarcodeFormat.CODE_128,100,200); DataMatrix码123456789101112131415public Bitmap getDataMatrix(string inputData, int barcodeWidth, int barcodeHeight)&#123; DatamatrixEncodingOptions options = new DatamatrixEncodingOptions() &#123; Width = barcodeWidth,//宽度 Height = barcodeHeight,//高度 Margin = 0, PureBarcode = true, SymbolShape = SymbolShapeHint.FORCE_SQUARE &#125;; options.Hints.Add(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); BarcodeWriter writer = new BarcodeWriter() &#123; Format = BarcodeFormat.DATA_MATRIX, Options = options &#125;; return writer.Write(inputData);&#125; 调用: 1Bitmap bitmap = getDataMatrix(\"1234567890987654321\",100,200); 效果图： 二、打印输出打印工具类条码图片生成了接下来自然就是打印输出到纸张上了，NET 打印方式有很多，这次我们采用 PrintDocument 来输出打印。二话不说，直接上代码！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126namespace Barcode.util&#123; class PrintUtils &#123; public static PrintUtils Instance = new PrintUtils(); private PrintDocument printDocument = null; /// &lt;summary&gt; /// 条码图片 /// &lt;/summary&gt; private Image mBitmpa; /// &lt;summary&gt; /// 纸张宽度 单位定义为毫米mm /// &lt;/summary&gt; public int paperWidth; /// &lt;summary&gt; /// 纸张高度 单位定义为毫米mm /// &lt;/summary&gt; public int paperHeight; private PrintUtils() &#123; printDocument = new PrintDocument(); #region 添加事件监听 printDocument.BeginPrint += new PrintEventHandler(printDocument_BeginPrint); printDocument.PrintPage += new PrintPageEventHandler(printDocument_PrintPage); printDocument.EndPrint += new PrintEventHandler(printDocument_EndPrint); #endregion &#125; #region 设置打印属性设置 /// &lt;summary&gt; /// 设置打印属性 /// &lt;/summary&gt; private void setPrintProperties() &#123; // 设置文档名 printDocument.DocumentName = \"条码打印\";//设置完后可在打印对话框及队列中显示（默认显示document） // 设置选择的打印机名称 printDocument.PrinterSettings.PrinterName = \"TEC B-SX5\"; // 设置纸张大小（可以不设置取，取默认设置） PaperSize ps = new PaperSize(\"Your Paper Name\", (int)(paperWidth / 25.4 * 100), (int)(paperHeight / 25.4 * 100)); ps.RawKind = 150; //如果是自定义纸张，就要大于118 printDocument.DefaultPageSettings.PaperSize = ps; printDocument.DefaultPageSettings.Landscape = true; &#125; #endregion #region 打印机事件监听 #region 打印前事件 /// &lt;summary&gt; /// 打印前事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"e\"&gt;&lt;/param&gt; void printDocument_BeginPrint(object sender, PrintEventArgs e) &#123; //设置打印属性 setPrintProperties(); &#125; #endregion #region 打印输出时(过程)事件 /// &lt;summary&gt; /// 打印输出时(过程)事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"e\"&gt;&lt;/param&gt; void printDocument_PrintPage(object sender, PrintPageEventArgs e) &#123; // 打印输出信息 Graphics g = e.Graphics; g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias; #region 在画布上画图片 g.DrawImage( mBitmpa, new System.Drawing.Rectangle(5, 5, mBitmpa.Width, mBitmpa.Height), new System.Drawing.Rectangle(0, 0, mBitmpa.Width, mBitmpa.Height), System.Drawing.GraphicsUnit.Pixel); #endregion &#125; #endregion #region 打印结束事件 /// &lt;summary&gt; /// 打印结束事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"e\"&gt;&lt;/param&gt; void printDocument_EndPrint(object sender, PrintEventArgs e) &#123; // 打印结束后相关操作 &#125; #endregion #endregion #region 打印预览 /// &lt;summary&gt; /// 打印预览 /// &lt;/summary&gt; /// &lt;param name=\"mBitmpa\"&gt;&lt;/param&gt; public void printPreview(Image mBitmpa, int paperWidth, int paperHeight) &#123; this.mBitmpa = mBitmpa; this.paperWidth = paperWidth; this.paperHeight = paperHeight; PrintPreviewDialog ppd = new PrintPreviewDialog(); ppd.Document = printDocument; ppd.ShowDialog(); &#125; #endregion #region 打印图片 /// &lt;summary&gt; /// 打印图片 /// &lt;/summary&gt; /// &lt;param name=\"mBitmpa\"&gt;图片源&lt;/param&gt; /// &lt;param name=\"mModel\"&gt;配置信息&lt;/param&gt; public void printPicture(Image mBitmpa, int paperWidth, int paperHeight) &#123; this.mBitmpa = mBitmpa; this.paperWidth = paperWidth; this.paperHeight = paperHeight; printDocument.Print(); &#125; #endregion &#125;&#125; 调用:1PrintUtils.Instance.printPreview(this.pictureBox1.Image, pictureBox1.Width, pictureBox1.Height); 打印机设置本次打印机采用 东芝B-SX5，纸张形状为卷状，并且两张之间有间隔。打印机如果未设置好的话，会出现出纸长度不一的现象。","tags":[{"name":"C#","slug":"C","permalink":"https://marklogzhu.github.io/tags/C/"}]}]